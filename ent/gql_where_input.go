// Code generated by entc, DO NOT EDIT.

package ent

import (
	"fmt"
	"time"

	"github.com/cartridge-gg/starknet-indexer/ent/balance"
	"github.com/cartridge-gg/starknet-indexer/ent/block"
	"github.com/cartridge-gg/starknet-indexer/ent/contract"
	"github.com/cartridge-gg/starknet-indexer/ent/event"
	"github.com/cartridge-gg/starknet-indexer/ent/predicate"
	"github.com/cartridge-gg/starknet-indexer/ent/schema/big"
	"github.com/cartridge-gg/starknet-indexer/ent/transaction"
	"github.com/cartridge-gg/starknet-indexer/ent/transactionreceipt"
)

// BalanceWhereInput represents a where input for filtering Balance queries.
type BalanceWhereInput struct {
	Not *BalanceWhereInput   `json:"not,omitempty"`
	Or  []*BalanceWhereInput `json:"or,omitempty"`
	And []*BalanceWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *string  `json:"id,omitempty"`
	IDNEQ   *string  `json:"idNEQ,omitempty"`
	IDIn    []string `json:"idIn,omitempty"`
	IDNotIn []string `json:"idNotIn,omitempty"`
	IDGT    *string  `json:"idGT,omitempty"`
	IDGTE   *string  `json:"idGTE,omitempty"`
	IDLT    *string  `json:"idLT,omitempty"`
	IDLTE   *string  `json:"idLTE,omitempty"`

	// "tokenId" field predicates.
	TokenId       *big.Int  `json:"tokenid,omitempty"`
	TokenIdNEQ    *big.Int  `json:"tokenidNEQ,omitempty"`
	TokenIdIn     []big.Int `json:"tokenidIn,omitempty"`
	TokenIdNotIn  []big.Int `json:"tokenidNotIn,omitempty"`
	TokenIdGT     *big.Int  `json:"tokenidGT,omitempty"`
	TokenIdGTE    *big.Int  `json:"tokenidGTE,omitempty"`
	TokenIdLT     *big.Int  `json:"tokenidLT,omitempty"`
	TokenIdLTE    *big.Int  `json:"tokenidLTE,omitempty"`
	TokenIdIsNil  bool      `json:"tokenidIsNil,omitempty"`
	TokenIdNotNil bool      `json:"tokenidNotNil,omitempty"`

	// "balance" field predicates.
	Balance      *big.Int  `json:"balance,omitempty"`
	BalanceNEQ   *big.Int  `json:"balanceNEQ,omitempty"`
	BalanceIn    []big.Int `json:"balanceIn,omitempty"`
	BalanceNotIn []big.Int `json:"balanceNotIn,omitempty"`
	BalanceGT    *big.Int  `json:"balanceGT,omitempty"`
	BalanceGTE   *big.Int  `json:"balanceGTE,omitempty"`
	BalanceLT    *big.Int  `json:"balanceLT,omitempty"`
	BalanceLTE   *big.Int  `json:"balanceLTE,omitempty"`

	// "account" edge predicates.
	HasAccount     *bool                 `json:"hasAccount,omitempty"`
	HasAccountWith []*ContractWhereInput `json:"hasAccountWith,omitempty"`

	// "contract" edge predicates.
	HasContract     *bool                 `json:"hasContract,omitempty"`
	HasContractWith []*ContractWhereInput `json:"hasContractWith,omitempty"`
}

// Filter applies the BalanceWhereInput filter on the BalanceQuery builder.
func (i *BalanceWhereInput) Filter(q *BalanceQuery) (*BalanceQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering balances.
// An error is returned if the input is empty or invalid.
func (i *BalanceWhereInput) P() (predicate.Balance, error) {
	var predicates []predicate.Balance
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, balance.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Balance, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, balance.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Balance, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, balance.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, balance.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, balance.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, balance.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, balance.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, balance.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, balance.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, balance.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, balance.IDLTE(*i.IDLTE))
	}
	if i.TokenId != nil {
		predicates = append(predicates, balance.TokenIdEQ(*i.TokenId))
	}
	if i.TokenIdNEQ != nil {
		predicates = append(predicates, balance.TokenIdNEQ(*i.TokenIdNEQ))
	}
	if len(i.TokenIdIn) > 0 {
		predicates = append(predicates, balance.TokenIdIn(i.TokenIdIn...))
	}
	if len(i.TokenIdNotIn) > 0 {
		predicates = append(predicates, balance.TokenIdNotIn(i.TokenIdNotIn...))
	}
	if i.TokenIdGT != nil {
		predicates = append(predicates, balance.TokenIdGT(*i.TokenIdGT))
	}
	if i.TokenIdGTE != nil {
		predicates = append(predicates, balance.TokenIdGTE(*i.TokenIdGTE))
	}
	if i.TokenIdLT != nil {
		predicates = append(predicates, balance.TokenIdLT(*i.TokenIdLT))
	}
	if i.TokenIdLTE != nil {
		predicates = append(predicates, balance.TokenIdLTE(*i.TokenIdLTE))
	}
	if i.TokenIdIsNil {
		predicates = append(predicates, balance.TokenIdIsNil())
	}
	if i.TokenIdNotNil {
		predicates = append(predicates, balance.TokenIdNotNil())
	}
	if i.Balance != nil {
		predicates = append(predicates, balance.BalanceEQ(*i.Balance))
	}
	if i.BalanceNEQ != nil {
		predicates = append(predicates, balance.BalanceNEQ(*i.BalanceNEQ))
	}
	if len(i.BalanceIn) > 0 {
		predicates = append(predicates, balance.BalanceIn(i.BalanceIn...))
	}
	if len(i.BalanceNotIn) > 0 {
		predicates = append(predicates, balance.BalanceNotIn(i.BalanceNotIn...))
	}
	if i.BalanceGT != nil {
		predicates = append(predicates, balance.BalanceGT(*i.BalanceGT))
	}
	if i.BalanceGTE != nil {
		predicates = append(predicates, balance.BalanceGTE(*i.BalanceGTE))
	}
	if i.BalanceLT != nil {
		predicates = append(predicates, balance.BalanceLT(*i.BalanceLT))
	}
	if i.BalanceLTE != nil {
		predicates = append(predicates, balance.BalanceLTE(*i.BalanceLTE))
	}

	if i.HasAccount != nil {
		p := balance.HasAccount()
		if !*i.HasAccount {
			p = balance.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAccountWith) > 0 {
		with := make([]predicate.Contract, 0, len(i.HasAccountWith))
		for _, w := range i.HasAccountWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, balance.HasAccountWith(with...))
	}
	if i.HasContract != nil {
		p := balance.HasContract()
		if !*i.HasContract {
			p = balance.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasContractWith) > 0 {
		with := make([]predicate.Contract, 0, len(i.HasContractWith))
		for _, w := range i.HasContractWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, balance.HasContractWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("empty predicate BalanceWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return balance.And(predicates...), nil
	}
}

// BlockWhereInput represents a where input for filtering Block queries.
type BlockWhereInput struct {
	Not *BlockWhereInput   `json:"not,omitempty"`
	Or  []*BlockWhereInput `json:"or,omitempty"`
	And []*BlockWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *string  `json:"id,omitempty"`
	IDNEQ   *string  `json:"idNEQ,omitempty"`
	IDIn    []string `json:"idIn,omitempty"`
	IDNotIn []string `json:"idNotIn,omitempty"`
	IDGT    *string  `json:"idGT,omitempty"`
	IDGTE   *string  `json:"idGTE,omitempty"`
	IDLT    *string  `json:"idLT,omitempty"`
	IDLTE   *string  `json:"idLTE,omitempty"`

	// "block_hash" field predicates.
	BlockHash             *string  `json:"blockHash,omitempty"`
	BlockHashNEQ          *string  `json:"blockHashNEQ,omitempty"`
	BlockHashIn           []string `json:"blockHashIn,omitempty"`
	BlockHashNotIn        []string `json:"blockHashNotIn,omitempty"`
	BlockHashGT           *string  `json:"blockHashGT,omitempty"`
	BlockHashGTE          *string  `json:"blockHashGTE,omitempty"`
	BlockHashLT           *string  `json:"blockHashLT,omitempty"`
	BlockHashLTE          *string  `json:"blockHashLTE,omitempty"`
	BlockHashContains     *string  `json:"blockHashContains,omitempty"`
	BlockHashHasPrefix    *string  `json:"blockHashHasPrefix,omitempty"`
	BlockHashHasSuffix    *string  `json:"blockHashHasSuffix,omitempty"`
	BlockHashEqualFold    *string  `json:"blockHashEqualFold,omitempty"`
	BlockHashContainsFold *string  `json:"blockHashContainsFold,omitempty"`

	// "parent_block_hash" field predicates.
	ParentBlockHash             *string  `json:"parentBlockHash,omitempty"`
	ParentBlockHashNEQ          *string  `json:"parentBlockHashNEQ,omitempty"`
	ParentBlockHashIn           []string `json:"parentBlockHashIn,omitempty"`
	ParentBlockHashNotIn        []string `json:"parentBlockHashNotIn,omitempty"`
	ParentBlockHashGT           *string  `json:"parentBlockHashGT,omitempty"`
	ParentBlockHashGTE          *string  `json:"parentBlockHashGTE,omitempty"`
	ParentBlockHashLT           *string  `json:"parentBlockHashLT,omitempty"`
	ParentBlockHashLTE          *string  `json:"parentBlockHashLTE,omitempty"`
	ParentBlockHashContains     *string  `json:"parentBlockHashContains,omitempty"`
	ParentBlockHashHasPrefix    *string  `json:"parentBlockHashHasPrefix,omitempty"`
	ParentBlockHashHasSuffix    *string  `json:"parentBlockHashHasSuffix,omitempty"`
	ParentBlockHashEqualFold    *string  `json:"parentBlockHashEqualFold,omitempty"`
	ParentBlockHashContainsFold *string  `json:"parentBlockHashContainsFold,omitempty"`

	// "block_number" field predicates.
	BlockNumber      *uint64  `json:"blockNumber,omitempty"`
	BlockNumberNEQ   *uint64  `json:"blockNumberNEQ,omitempty"`
	BlockNumberIn    []uint64 `json:"blockNumberIn,omitempty"`
	BlockNumberNotIn []uint64 `json:"blockNumberNotIn,omitempty"`
	BlockNumberGT    *uint64  `json:"blockNumberGT,omitempty"`
	BlockNumberGTE   *uint64  `json:"blockNumberGTE,omitempty"`
	BlockNumberLT    *uint64  `json:"blockNumberLT,omitempty"`
	BlockNumberLTE   *uint64  `json:"blockNumberLTE,omitempty"`

	// "state_root" field predicates.
	StateRoot             *string  `json:"stateRoot,omitempty"`
	StateRootNEQ          *string  `json:"stateRootNEQ,omitempty"`
	StateRootIn           []string `json:"stateRootIn,omitempty"`
	StateRootNotIn        []string `json:"stateRootNotIn,omitempty"`
	StateRootGT           *string  `json:"stateRootGT,omitempty"`
	StateRootGTE          *string  `json:"stateRootGTE,omitempty"`
	StateRootLT           *string  `json:"stateRootLT,omitempty"`
	StateRootLTE          *string  `json:"stateRootLTE,omitempty"`
	StateRootContains     *string  `json:"stateRootContains,omitempty"`
	StateRootHasPrefix    *string  `json:"stateRootHasPrefix,omitempty"`
	StateRootHasSuffix    *string  `json:"stateRootHasSuffix,omitempty"`
	StateRootEqualFold    *string  `json:"stateRootEqualFold,omitempty"`
	StateRootContainsFold *string  `json:"stateRootContainsFold,omitempty"`

	// "status" field predicates.
	Status      *block.Status  `json:"status,omitempty"`
	StatusNEQ   *block.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []block.Status `json:"statusIn,omitempty"`
	StatusNotIn []block.Status `json:"statusNotIn,omitempty"`

	// "timestamp" field predicates.
	Timestamp      *time.Time  `json:"timestamp,omitempty"`
	TimestampNEQ   *time.Time  `json:"timestampNEQ,omitempty"`
	TimestampIn    []time.Time `json:"timestampIn,omitempty"`
	TimestampNotIn []time.Time `json:"timestampNotIn,omitempty"`
	TimestampGT    *time.Time  `json:"timestampGT,omitempty"`
	TimestampGTE   *time.Time  `json:"timestampGTE,omitempty"`
	TimestampLT    *time.Time  `json:"timestampLT,omitempty"`
	TimestampLTE   *time.Time  `json:"timestampLTE,omitempty"`

	// "transactions" edge predicates.
	HasTransactions     *bool                    `json:"hasTransactions,omitempty"`
	HasTransactionsWith []*TransactionWhereInput `json:"hasTransactionsWith,omitempty"`

	// "transaction_receipts" edge predicates.
	HasTransactionReceipts     *bool                           `json:"hasTransactionReceipts,omitempty"`
	HasTransactionReceiptsWith []*TransactionReceiptWhereInput `json:"hasTransactionReceiptsWith,omitempty"`
}

// Filter applies the BlockWhereInput filter on the BlockQuery builder.
func (i *BlockWhereInput) Filter(q *BlockQuery) (*BlockQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering blocks.
// An error is returned if the input is empty or invalid.
func (i *BlockWhereInput) P() (predicate.Block, error) {
	var predicates []predicate.Block
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, block.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Block, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, block.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Block, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, block.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, block.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, block.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, block.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, block.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, block.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, block.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, block.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, block.IDLTE(*i.IDLTE))
	}
	if i.BlockHash != nil {
		predicates = append(predicates, block.BlockHashEQ(*i.BlockHash))
	}
	if i.BlockHashNEQ != nil {
		predicates = append(predicates, block.BlockHashNEQ(*i.BlockHashNEQ))
	}
	if len(i.BlockHashIn) > 0 {
		predicates = append(predicates, block.BlockHashIn(i.BlockHashIn...))
	}
	if len(i.BlockHashNotIn) > 0 {
		predicates = append(predicates, block.BlockHashNotIn(i.BlockHashNotIn...))
	}
	if i.BlockHashGT != nil {
		predicates = append(predicates, block.BlockHashGT(*i.BlockHashGT))
	}
	if i.BlockHashGTE != nil {
		predicates = append(predicates, block.BlockHashGTE(*i.BlockHashGTE))
	}
	if i.BlockHashLT != nil {
		predicates = append(predicates, block.BlockHashLT(*i.BlockHashLT))
	}
	if i.BlockHashLTE != nil {
		predicates = append(predicates, block.BlockHashLTE(*i.BlockHashLTE))
	}
	if i.BlockHashContains != nil {
		predicates = append(predicates, block.BlockHashContains(*i.BlockHashContains))
	}
	if i.BlockHashHasPrefix != nil {
		predicates = append(predicates, block.BlockHashHasPrefix(*i.BlockHashHasPrefix))
	}
	if i.BlockHashHasSuffix != nil {
		predicates = append(predicates, block.BlockHashHasSuffix(*i.BlockHashHasSuffix))
	}
	if i.BlockHashEqualFold != nil {
		predicates = append(predicates, block.BlockHashEqualFold(*i.BlockHashEqualFold))
	}
	if i.BlockHashContainsFold != nil {
		predicates = append(predicates, block.BlockHashContainsFold(*i.BlockHashContainsFold))
	}
	if i.ParentBlockHash != nil {
		predicates = append(predicates, block.ParentBlockHashEQ(*i.ParentBlockHash))
	}
	if i.ParentBlockHashNEQ != nil {
		predicates = append(predicates, block.ParentBlockHashNEQ(*i.ParentBlockHashNEQ))
	}
	if len(i.ParentBlockHashIn) > 0 {
		predicates = append(predicates, block.ParentBlockHashIn(i.ParentBlockHashIn...))
	}
	if len(i.ParentBlockHashNotIn) > 0 {
		predicates = append(predicates, block.ParentBlockHashNotIn(i.ParentBlockHashNotIn...))
	}
	if i.ParentBlockHashGT != nil {
		predicates = append(predicates, block.ParentBlockHashGT(*i.ParentBlockHashGT))
	}
	if i.ParentBlockHashGTE != nil {
		predicates = append(predicates, block.ParentBlockHashGTE(*i.ParentBlockHashGTE))
	}
	if i.ParentBlockHashLT != nil {
		predicates = append(predicates, block.ParentBlockHashLT(*i.ParentBlockHashLT))
	}
	if i.ParentBlockHashLTE != nil {
		predicates = append(predicates, block.ParentBlockHashLTE(*i.ParentBlockHashLTE))
	}
	if i.ParentBlockHashContains != nil {
		predicates = append(predicates, block.ParentBlockHashContains(*i.ParentBlockHashContains))
	}
	if i.ParentBlockHashHasPrefix != nil {
		predicates = append(predicates, block.ParentBlockHashHasPrefix(*i.ParentBlockHashHasPrefix))
	}
	if i.ParentBlockHashHasSuffix != nil {
		predicates = append(predicates, block.ParentBlockHashHasSuffix(*i.ParentBlockHashHasSuffix))
	}
	if i.ParentBlockHashEqualFold != nil {
		predicates = append(predicates, block.ParentBlockHashEqualFold(*i.ParentBlockHashEqualFold))
	}
	if i.ParentBlockHashContainsFold != nil {
		predicates = append(predicates, block.ParentBlockHashContainsFold(*i.ParentBlockHashContainsFold))
	}
	if i.BlockNumber != nil {
		predicates = append(predicates, block.BlockNumberEQ(*i.BlockNumber))
	}
	if i.BlockNumberNEQ != nil {
		predicates = append(predicates, block.BlockNumberNEQ(*i.BlockNumberNEQ))
	}
	if len(i.BlockNumberIn) > 0 {
		predicates = append(predicates, block.BlockNumberIn(i.BlockNumberIn...))
	}
	if len(i.BlockNumberNotIn) > 0 {
		predicates = append(predicates, block.BlockNumberNotIn(i.BlockNumberNotIn...))
	}
	if i.BlockNumberGT != nil {
		predicates = append(predicates, block.BlockNumberGT(*i.BlockNumberGT))
	}
	if i.BlockNumberGTE != nil {
		predicates = append(predicates, block.BlockNumberGTE(*i.BlockNumberGTE))
	}
	if i.BlockNumberLT != nil {
		predicates = append(predicates, block.BlockNumberLT(*i.BlockNumberLT))
	}
	if i.BlockNumberLTE != nil {
		predicates = append(predicates, block.BlockNumberLTE(*i.BlockNumberLTE))
	}
	if i.StateRoot != nil {
		predicates = append(predicates, block.StateRootEQ(*i.StateRoot))
	}
	if i.StateRootNEQ != nil {
		predicates = append(predicates, block.StateRootNEQ(*i.StateRootNEQ))
	}
	if len(i.StateRootIn) > 0 {
		predicates = append(predicates, block.StateRootIn(i.StateRootIn...))
	}
	if len(i.StateRootNotIn) > 0 {
		predicates = append(predicates, block.StateRootNotIn(i.StateRootNotIn...))
	}
	if i.StateRootGT != nil {
		predicates = append(predicates, block.StateRootGT(*i.StateRootGT))
	}
	if i.StateRootGTE != nil {
		predicates = append(predicates, block.StateRootGTE(*i.StateRootGTE))
	}
	if i.StateRootLT != nil {
		predicates = append(predicates, block.StateRootLT(*i.StateRootLT))
	}
	if i.StateRootLTE != nil {
		predicates = append(predicates, block.StateRootLTE(*i.StateRootLTE))
	}
	if i.StateRootContains != nil {
		predicates = append(predicates, block.StateRootContains(*i.StateRootContains))
	}
	if i.StateRootHasPrefix != nil {
		predicates = append(predicates, block.StateRootHasPrefix(*i.StateRootHasPrefix))
	}
	if i.StateRootHasSuffix != nil {
		predicates = append(predicates, block.StateRootHasSuffix(*i.StateRootHasSuffix))
	}
	if i.StateRootEqualFold != nil {
		predicates = append(predicates, block.StateRootEqualFold(*i.StateRootEqualFold))
	}
	if i.StateRootContainsFold != nil {
		predicates = append(predicates, block.StateRootContainsFold(*i.StateRootContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, block.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, block.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, block.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, block.StatusNotIn(i.StatusNotIn...))
	}
	if i.Timestamp != nil {
		predicates = append(predicates, block.TimestampEQ(*i.Timestamp))
	}
	if i.TimestampNEQ != nil {
		predicates = append(predicates, block.TimestampNEQ(*i.TimestampNEQ))
	}
	if len(i.TimestampIn) > 0 {
		predicates = append(predicates, block.TimestampIn(i.TimestampIn...))
	}
	if len(i.TimestampNotIn) > 0 {
		predicates = append(predicates, block.TimestampNotIn(i.TimestampNotIn...))
	}
	if i.TimestampGT != nil {
		predicates = append(predicates, block.TimestampGT(*i.TimestampGT))
	}
	if i.TimestampGTE != nil {
		predicates = append(predicates, block.TimestampGTE(*i.TimestampGTE))
	}
	if i.TimestampLT != nil {
		predicates = append(predicates, block.TimestampLT(*i.TimestampLT))
	}
	if i.TimestampLTE != nil {
		predicates = append(predicates, block.TimestampLTE(*i.TimestampLTE))
	}

	if i.HasTransactions != nil {
		p := block.HasTransactions()
		if !*i.HasTransactions {
			p = block.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTransactionsWith) > 0 {
		with := make([]predicate.Transaction, 0, len(i.HasTransactionsWith))
		for _, w := range i.HasTransactionsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, block.HasTransactionsWith(with...))
	}
	if i.HasTransactionReceipts != nil {
		p := block.HasTransactionReceipts()
		if !*i.HasTransactionReceipts {
			p = block.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTransactionReceiptsWith) > 0 {
		with := make([]predicate.TransactionReceipt, 0, len(i.HasTransactionReceiptsWith))
		for _, w := range i.HasTransactionReceiptsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, block.HasTransactionReceiptsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("empty predicate BlockWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return block.And(predicates...), nil
	}
}

// ContractWhereInput represents a where input for filtering Contract queries.
type ContractWhereInput struct {
	Not *ContractWhereInput   `json:"not,omitempty"`
	Or  []*ContractWhereInput `json:"or,omitempty"`
	And []*ContractWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *string  `json:"id,omitempty"`
	IDNEQ   *string  `json:"idNEQ,omitempty"`
	IDIn    []string `json:"idIn,omitempty"`
	IDNotIn []string `json:"idNotIn,omitempty"`
	IDGT    *string  `json:"idGT,omitempty"`
	IDGTE   *string  `json:"idGTE,omitempty"`
	IDLT    *string  `json:"idLT,omitempty"`
	IDLTE   *string  `json:"idLTE,omitempty"`

	// "type" field predicates.
	Type      *contract.Type  `json:"type,omitempty"`
	TypeNEQ   *contract.Type  `json:"typeNEQ,omitempty"`
	TypeIn    []contract.Type `json:"typeIn,omitempty"`
	TypeNotIn []contract.Type `json:"typeNotIn,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "transactions" edge predicates.
	HasTransactions     *bool                    `json:"hasTransactions,omitempty"`
	HasTransactionsWith []*TransactionWhereInput `json:"hasTransactionsWith,omitempty"`
}

// Filter applies the ContractWhereInput filter on the ContractQuery builder.
func (i *ContractWhereInput) Filter(q *ContractQuery) (*ContractQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering contracts.
// An error is returned if the input is empty or invalid.
func (i *ContractWhereInput) P() (predicate.Contract, error) {
	var predicates []predicate.Contract
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, contract.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Contract, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, contract.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Contract, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, contract.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, contract.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, contract.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, contract.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, contract.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, contract.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, contract.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, contract.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, contract.IDLTE(*i.IDLTE))
	}
	if i.Type != nil {
		predicates = append(predicates, contract.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, contract.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, contract.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, contract.TypeNotIn(i.TypeNotIn...))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, contract.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, contract.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, contract.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, contract.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, contract.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, contract.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, contract.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, contract.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, contract.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, contract.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, contract.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, contract.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, contract.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, contract.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, contract.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, contract.UpdatedAtLTE(*i.UpdatedAtLTE))
	}

	if i.HasTransactions != nil {
		p := contract.HasTransactions()
		if !*i.HasTransactions {
			p = contract.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTransactionsWith) > 0 {
		with := make([]predicate.Transaction, 0, len(i.HasTransactionsWith))
		for _, w := range i.HasTransactionsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, contract.HasTransactionsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("empty predicate ContractWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return contract.And(predicates...), nil
	}
}

// EventWhereInput represents a where input for filtering Event queries.
type EventWhereInput struct {
	Not *EventWhereInput   `json:"not,omitempty"`
	Or  []*EventWhereInput `json:"or,omitempty"`
	And []*EventWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *string  `json:"id,omitempty"`
	IDNEQ   *string  `json:"idNEQ,omitempty"`
	IDIn    []string `json:"idIn,omitempty"`
	IDNotIn []string `json:"idNotIn,omitempty"`
	IDGT    *string  `json:"idGT,omitempty"`
	IDGTE   *string  `json:"idGTE,omitempty"`
	IDLT    *string  `json:"idLT,omitempty"`
	IDLTE   *string  `json:"idLTE,omitempty"`

	// "from" field predicates.
	From             *string  `json:"from,omitempty"`
	FromNEQ          *string  `json:"fromNEQ,omitempty"`
	FromIn           []string `json:"fromIn,omitempty"`
	FromNotIn        []string `json:"fromNotIn,omitempty"`
	FromGT           *string  `json:"fromGT,omitempty"`
	FromGTE          *string  `json:"fromGTE,omitempty"`
	FromLT           *string  `json:"fromLT,omitempty"`
	FromLTE          *string  `json:"fromLTE,omitempty"`
	FromContains     *string  `json:"fromContains,omitempty"`
	FromHasPrefix    *string  `json:"fromHasPrefix,omitempty"`
	FromHasSuffix    *string  `json:"fromHasSuffix,omitempty"`
	FromEqualFold    *string  `json:"fromEqualFold,omitempty"`
	FromContainsFold *string  `json:"fromContainsFold,omitempty"`

	// "transaction" edge predicates.
	HasTransaction     *bool                    `json:"hasTransaction,omitempty"`
	HasTransactionWith []*TransactionWhereInput `json:"hasTransactionWith,omitempty"`
}

// Filter applies the EventWhereInput filter on the EventQuery builder.
func (i *EventWhereInput) Filter(q *EventQuery) (*EventQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering events.
// An error is returned if the input is empty or invalid.
func (i *EventWhereInput) P() (predicate.Event, error) {
	var predicates []predicate.Event
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, event.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Event, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, event.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Event, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, event.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, event.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, event.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, event.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, event.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, event.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, event.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, event.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, event.IDLTE(*i.IDLTE))
	}
	if i.From != nil {
		predicates = append(predicates, event.FromEQ(*i.From))
	}
	if i.FromNEQ != nil {
		predicates = append(predicates, event.FromNEQ(*i.FromNEQ))
	}
	if len(i.FromIn) > 0 {
		predicates = append(predicates, event.FromIn(i.FromIn...))
	}
	if len(i.FromNotIn) > 0 {
		predicates = append(predicates, event.FromNotIn(i.FromNotIn...))
	}
	if i.FromGT != nil {
		predicates = append(predicates, event.FromGT(*i.FromGT))
	}
	if i.FromGTE != nil {
		predicates = append(predicates, event.FromGTE(*i.FromGTE))
	}
	if i.FromLT != nil {
		predicates = append(predicates, event.FromLT(*i.FromLT))
	}
	if i.FromLTE != nil {
		predicates = append(predicates, event.FromLTE(*i.FromLTE))
	}
	if i.FromContains != nil {
		predicates = append(predicates, event.FromContains(*i.FromContains))
	}
	if i.FromHasPrefix != nil {
		predicates = append(predicates, event.FromHasPrefix(*i.FromHasPrefix))
	}
	if i.FromHasSuffix != nil {
		predicates = append(predicates, event.FromHasSuffix(*i.FromHasSuffix))
	}
	if i.FromEqualFold != nil {
		predicates = append(predicates, event.FromEqualFold(*i.FromEqualFold))
	}
	if i.FromContainsFold != nil {
		predicates = append(predicates, event.FromContainsFold(*i.FromContainsFold))
	}

	if i.HasTransaction != nil {
		p := event.HasTransaction()
		if !*i.HasTransaction {
			p = event.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTransactionWith) > 0 {
		with := make([]predicate.Transaction, 0, len(i.HasTransactionWith))
		for _, w := range i.HasTransactionWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, event.HasTransactionWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("empty predicate EventWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return event.And(predicates...), nil
	}
}

// TransactionWhereInput represents a where input for filtering Transaction queries.
type TransactionWhereInput struct {
	Not *TransactionWhereInput   `json:"not,omitempty"`
	Or  []*TransactionWhereInput `json:"or,omitempty"`
	And []*TransactionWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *string  `json:"id,omitempty"`
	IDNEQ   *string  `json:"idNEQ,omitempty"`
	IDIn    []string `json:"idIn,omitempty"`
	IDNotIn []string `json:"idNotIn,omitempty"`
	IDGT    *string  `json:"idGT,omitempty"`
	IDGTE   *string  `json:"idGTE,omitempty"`
	IDLT    *string  `json:"idLT,omitempty"`
	IDLTE   *string  `json:"idLTE,omitempty"`

	// "contract_address" field predicates.
	ContractAddress             *string  `json:"contractAddress,omitempty"`
	ContractAddressNEQ          *string  `json:"contractAddressNEQ,omitempty"`
	ContractAddressIn           []string `json:"contractAddressIn,omitempty"`
	ContractAddressNotIn        []string `json:"contractAddressNotIn,omitempty"`
	ContractAddressGT           *string  `json:"contractAddressGT,omitempty"`
	ContractAddressGTE          *string  `json:"contractAddressGTE,omitempty"`
	ContractAddressLT           *string  `json:"contractAddressLT,omitempty"`
	ContractAddressLTE          *string  `json:"contractAddressLTE,omitempty"`
	ContractAddressContains     *string  `json:"contractAddressContains,omitempty"`
	ContractAddressHasPrefix    *string  `json:"contractAddressHasPrefix,omitempty"`
	ContractAddressHasSuffix    *string  `json:"contractAddressHasSuffix,omitempty"`
	ContractAddressEqualFold    *string  `json:"contractAddressEqualFold,omitempty"`
	ContractAddressContainsFold *string  `json:"contractAddressContainsFold,omitempty"`

	// "entry_point_selector" field predicates.
	EntryPointSelector             *string  `json:"entryPointSelector,omitempty"`
	EntryPointSelectorNEQ          *string  `json:"entryPointSelectorNEQ,omitempty"`
	EntryPointSelectorIn           []string `json:"entryPointSelectorIn,omitempty"`
	EntryPointSelectorNotIn        []string `json:"entryPointSelectorNotIn,omitempty"`
	EntryPointSelectorGT           *string  `json:"entryPointSelectorGT,omitempty"`
	EntryPointSelectorGTE          *string  `json:"entryPointSelectorGTE,omitempty"`
	EntryPointSelectorLT           *string  `json:"entryPointSelectorLT,omitempty"`
	EntryPointSelectorLTE          *string  `json:"entryPointSelectorLTE,omitempty"`
	EntryPointSelectorContains     *string  `json:"entryPointSelectorContains,omitempty"`
	EntryPointSelectorHasPrefix    *string  `json:"entryPointSelectorHasPrefix,omitempty"`
	EntryPointSelectorHasSuffix    *string  `json:"entryPointSelectorHasSuffix,omitempty"`
	EntryPointSelectorIsNil        bool     `json:"entryPointSelectorIsNil,omitempty"`
	EntryPointSelectorNotNil       bool     `json:"entryPointSelectorNotNil,omitempty"`
	EntryPointSelectorEqualFold    *string  `json:"entryPointSelectorEqualFold,omitempty"`
	EntryPointSelectorContainsFold *string  `json:"entryPointSelectorContainsFold,omitempty"`

	// "transaction_hash" field predicates.
	TransactionHash             *string  `json:"transactionHash,omitempty"`
	TransactionHashNEQ          *string  `json:"transactionHashNEQ,omitempty"`
	TransactionHashIn           []string `json:"transactionHashIn,omitempty"`
	TransactionHashNotIn        []string `json:"transactionHashNotIn,omitempty"`
	TransactionHashGT           *string  `json:"transactionHashGT,omitempty"`
	TransactionHashGTE          *string  `json:"transactionHashGTE,omitempty"`
	TransactionHashLT           *string  `json:"transactionHashLT,omitempty"`
	TransactionHashLTE          *string  `json:"transactionHashLTE,omitempty"`
	TransactionHashContains     *string  `json:"transactionHashContains,omitempty"`
	TransactionHashHasPrefix    *string  `json:"transactionHashHasPrefix,omitempty"`
	TransactionHashHasSuffix    *string  `json:"transactionHashHasSuffix,omitempty"`
	TransactionHashEqualFold    *string  `json:"transactionHashEqualFold,omitempty"`
	TransactionHashContainsFold *string  `json:"transactionHashContainsFold,omitempty"`

	// "nonce" field predicates.
	Nonce             *string  `json:"nonce,omitempty"`
	NonceNEQ          *string  `json:"nonceNEQ,omitempty"`
	NonceIn           []string `json:"nonceIn,omitempty"`
	NonceNotIn        []string `json:"nonceNotIn,omitempty"`
	NonceGT           *string  `json:"nonceGT,omitempty"`
	NonceGTE          *string  `json:"nonceGTE,omitempty"`
	NonceLT           *string  `json:"nonceLT,omitempty"`
	NonceLTE          *string  `json:"nonceLTE,omitempty"`
	NonceContains     *string  `json:"nonceContains,omitempty"`
	NonceHasPrefix    *string  `json:"nonceHasPrefix,omitempty"`
	NonceHasSuffix    *string  `json:"nonceHasSuffix,omitempty"`
	NonceIsNil        bool     `json:"nonceIsNil,omitempty"`
	NonceNotNil       bool     `json:"nonceNotNil,omitempty"`
	NonceEqualFold    *string  `json:"nonceEqualFold,omitempty"`
	NonceContainsFold *string  `json:"nonceContainsFold,omitempty"`

	// "block" edge predicates.
	HasBlock     *bool              `json:"hasBlock,omitempty"`
	HasBlockWith []*BlockWhereInput `json:"hasBlockWith,omitempty"`

	// "receipt" edge predicates.
	HasReceipt     *bool                           `json:"hasReceipt,omitempty"`
	HasReceiptWith []*TransactionReceiptWhereInput `json:"hasReceiptWith,omitempty"`

	// "events" edge predicates.
	HasEvents     *bool              `json:"hasEvents,omitempty"`
	HasEventsWith []*EventWhereInput `json:"hasEventsWith,omitempty"`
}

// Filter applies the TransactionWhereInput filter on the TransactionQuery builder.
func (i *TransactionWhereInput) Filter(q *TransactionQuery) (*TransactionQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering transactions.
// An error is returned if the input is empty or invalid.
func (i *TransactionWhereInput) P() (predicate.Transaction, error) {
	var predicates []predicate.Transaction
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, transaction.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Transaction, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, transaction.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Transaction, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, transaction.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, transaction.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, transaction.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, transaction.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, transaction.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, transaction.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, transaction.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, transaction.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, transaction.IDLTE(*i.IDLTE))
	}
	if i.ContractAddress != nil {
		predicates = append(predicates, transaction.ContractAddressEQ(*i.ContractAddress))
	}
	if i.ContractAddressNEQ != nil {
		predicates = append(predicates, transaction.ContractAddressNEQ(*i.ContractAddressNEQ))
	}
	if len(i.ContractAddressIn) > 0 {
		predicates = append(predicates, transaction.ContractAddressIn(i.ContractAddressIn...))
	}
	if len(i.ContractAddressNotIn) > 0 {
		predicates = append(predicates, transaction.ContractAddressNotIn(i.ContractAddressNotIn...))
	}
	if i.ContractAddressGT != nil {
		predicates = append(predicates, transaction.ContractAddressGT(*i.ContractAddressGT))
	}
	if i.ContractAddressGTE != nil {
		predicates = append(predicates, transaction.ContractAddressGTE(*i.ContractAddressGTE))
	}
	if i.ContractAddressLT != nil {
		predicates = append(predicates, transaction.ContractAddressLT(*i.ContractAddressLT))
	}
	if i.ContractAddressLTE != nil {
		predicates = append(predicates, transaction.ContractAddressLTE(*i.ContractAddressLTE))
	}
	if i.ContractAddressContains != nil {
		predicates = append(predicates, transaction.ContractAddressContains(*i.ContractAddressContains))
	}
	if i.ContractAddressHasPrefix != nil {
		predicates = append(predicates, transaction.ContractAddressHasPrefix(*i.ContractAddressHasPrefix))
	}
	if i.ContractAddressHasSuffix != nil {
		predicates = append(predicates, transaction.ContractAddressHasSuffix(*i.ContractAddressHasSuffix))
	}
	if i.ContractAddressEqualFold != nil {
		predicates = append(predicates, transaction.ContractAddressEqualFold(*i.ContractAddressEqualFold))
	}
	if i.ContractAddressContainsFold != nil {
		predicates = append(predicates, transaction.ContractAddressContainsFold(*i.ContractAddressContainsFold))
	}
	if i.EntryPointSelector != nil {
		predicates = append(predicates, transaction.EntryPointSelectorEQ(*i.EntryPointSelector))
	}
	if i.EntryPointSelectorNEQ != nil {
		predicates = append(predicates, transaction.EntryPointSelectorNEQ(*i.EntryPointSelectorNEQ))
	}
	if len(i.EntryPointSelectorIn) > 0 {
		predicates = append(predicates, transaction.EntryPointSelectorIn(i.EntryPointSelectorIn...))
	}
	if len(i.EntryPointSelectorNotIn) > 0 {
		predicates = append(predicates, transaction.EntryPointSelectorNotIn(i.EntryPointSelectorNotIn...))
	}
	if i.EntryPointSelectorGT != nil {
		predicates = append(predicates, transaction.EntryPointSelectorGT(*i.EntryPointSelectorGT))
	}
	if i.EntryPointSelectorGTE != nil {
		predicates = append(predicates, transaction.EntryPointSelectorGTE(*i.EntryPointSelectorGTE))
	}
	if i.EntryPointSelectorLT != nil {
		predicates = append(predicates, transaction.EntryPointSelectorLT(*i.EntryPointSelectorLT))
	}
	if i.EntryPointSelectorLTE != nil {
		predicates = append(predicates, transaction.EntryPointSelectorLTE(*i.EntryPointSelectorLTE))
	}
	if i.EntryPointSelectorContains != nil {
		predicates = append(predicates, transaction.EntryPointSelectorContains(*i.EntryPointSelectorContains))
	}
	if i.EntryPointSelectorHasPrefix != nil {
		predicates = append(predicates, transaction.EntryPointSelectorHasPrefix(*i.EntryPointSelectorHasPrefix))
	}
	if i.EntryPointSelectorHasSuffix != nil {
		predicates = append(predicates, transaction.EntryPointSelectorHasSuffix(*i.EntryPointSelectorHasSuffix))
	}
	if i.EntryPointSelectorIsNil {
		predicates = append(predicates, transaction.EntryPointSelectorIsNil())
	}
	if i.EntryPointSelectorNotNil {
		predicates = append(predicates, transaction.EntryPointSelectorNotNil())
	}
	if i.EntryPointSelectorEqualFold != nil {
		predicates = append(predicates, transaction.EntryPointSelectorEqualFold(*i.EntryPointSelectorEqualFold))
	}
	if i.EntryPointSelectorContainsFold != nil {
		predicates = append(predicates, transaction.EntryPointSelectorContainsFold(*i.EntryPointSelectorContainsFold))
	}
	if i.TransactionHash != nil {
		predicates = append(predicates, transaction.TransactionHashEQ(*i.TransactionHash))
	}
	if i.TransactionHashNEQ != nil {
		predicates = append(predicates, transaction.TransactionHashNEQ(*i.TransactionHashNEQ))
	}
	if len(i.TransactionHashIn) > 0 {
		predicates = append(predicates, transaction.TransactionHashIn(i.TransactionHashIn...))
	}
	if len(i.TransactionHashNotIn) > 0 {
		predicates = append(predicates, transaction.TransactionHashNotIn(i.TransactionHashNotIn...))
	}
	if i.TransactionHashGT != nil {
		predicates = append(predicates, transaction.TransactionHashGT(*i.TransactionHashGT))
	}
	if i.TransactionHashGTE != nil {
		predicates = append(predicates, transaction.TransactionHashGTE(*i.TransactionHashGTE))
	}
	if i.TransactionHashLT != nil {
		predicates = append(predicates, transaction.TransactionHashLT(*i.TransactionHashLT))
	}
	if i.TransactionHashLTE != nil {
		predicates = append(predicates, transaction.TransactionHashLTE(*i.TransactionHashLTE))
	}
	if i.TransactionHashContains != nil {
		predicates = append(predicates, transaction.TransactionHashContains(*i.TransactionHashContains))
	}
	if i.TransactionHashHasPrefix != nil {
		predicates = append(predicates, transaction.TransactionHashHasPrefix(*i.TransactionHashHasPrefix))
	}
	if i.TransactionHashHasSuffix != nil {
		predicates = append(predicates, transaction.TransactionHashHasSuffix(*i.TransactionHashHasSuffix))
	}
	if i.TransactionHashEqualFold != nil {
		predicates = append(predicates, transaction.TransactionHashEqualFold(*i.TransactionHashEqualFold))
	}
	if i.TransactionHashContainsFold != nil {
		predicates = append(predicates, transaction.TransactionHashContainsFold(*i.TransactionHashContainsFold))
	}
	if i.Nonce != nil {
		predicates = append(predicates, transaction.NonceEQ(*i.Nonce))
	}
	if i.NonceNEQ != nil {
		predicates = append(predicates, transaction.NonceNEQ(*i.NonceNEQ))
	}
	if len(i.NonceIn) > 0 {
		predicates = append(predicates, transaction.NonceIn(i.NonceIn...))
	}
	if len(i.NonceNotIn) > 0 {
		predicates = append(predicates, transaction.NonceNotIn(i.NonceNotIn...))
	}
	if i.NonceGT != nil {
		predicates = append(predicates, transaction.NonceGT(*i.NonceGT))
	}
	if i.NonceGTE != nil {
		predicates = append(predicates, transaction.NonceGTE(*i.NonceGTE))
	}
	if i.NonceLT != nil {
		predicates = append(predicates, transaction.NonceLT(*i.NonceLT))
	}
	if i.NonceLTE != nil {
		predicates = append(predicates, transaction.NonceLTE(*i.NonceLTE))
	}
	if i.NonceContains != nil {
		predicates = append(predicates, transaction.NonceContains(*i.NonceContains))
	}
	if i.NonceHasPrefix != nil {
		predicates = append(predicates, transaction.NonceHasPrefix(*i.NonceHasPrefix))
	}
	if i.NonceHasSuffix != nil {
		predicates = append(predicates, transaction.NonceHasSuffix(*i.NonceHasSuffix))
	}
	if i.NonceIsNil {
		predicates = append(predicates, transaction.NonceIsNil())
	}
	if i.NonceNotNil {
		predicates = append(predicates, transaction.NonceNotNil())
	}
	if i.NonceEqualFold != nil {
		predicates = append(predicates, transaction.NonceEqualFold(*i.NonceEqualFold))
	}
	if i.NonceContainsFold != nil {
		predicates = append(predicates, transaction.NonceContainsFold(*i.NonceContainsFold))
	}

	if i.HasBlock != nil {
		p := transaction.HasBlock()
		if !*i.HasBlock {
			p = transaction.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBlockWith) > 0 {
		with := make([]predicate.Block, 0, len(i.HasBlockWith))
		for _, w := range i.HasBlockWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, transaction.HasBlockWith(with...))
	}
	if i.HasReceipt != nil {
		p := transaction.HasReceipt()
		if !*i.HasReceipt {
			p = transaction.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasReceiptWith) > 0 {
		with := make([]predicate.TransactionReceipt, 0, len(i.HasReceiptWith))
		for _, w := range i.HasReceiptWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, transaction.HasReceiptWith(with...))
	}
	if i.HasEvents != nil {
		p := transaction.HasEvents()
		if !*i.HasEvents {
			p = transaction.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEventsWith) > 0 {
		with := make([]predicate.Event, 0, len(i.HasEventsWith))
		for _, w := range i.HasEventsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, transaction.HasEventsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("empty predicate TransactionWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return transaction.And(predicates...), nil
	}
}

// TransactionReceiptWhereInput represents a where input for filtering TransactionReceipt queries.
type TransactionReceiptWhereInput struct {
	Not *TransactionReceiptWhereInput   `json:"not,omitempty"`
	Or  []*TransactionReceiptWhereInput `json:"or,omitempty"`
	And []*TransactionReceiptWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *string  `json:"id,omitempty"`
	IDNEQ   *string  `json:"idNEQ,omitempty"`
	IDIn    []string `json:"idIn,omitempty"`
	IDNotIn []string `json:"idNotIn,omitempty"`
	IDGT    *string  `json:"idGT,omitempty"`
	IDGTE   *string  `json:"idGTE,omitempty"`
	IDLT    *string  `json:"idLT,omitempty"`
	IDLTE   *string  `json:"idLTE,omitempty"`

	// "transaction_hash" field predicates.
	TransactionHash             *string  `json:"transactionHash,omitempty"`
	TransactionHashNEQ          *string  `json:"transactionHashNEQ,omitempty"`
	TransactionHashIn           []string `json:"transactionHashIn,omitempty"`
	TransactionHashNotIn        []string `json:"transactionHashNotIn,omitempty"`
	TransactionHashGT           *string  `json:"transactionHashGT,omitempty"`
	TransactionHashGTE          *string  `json:"transactionHashGTE,omitempty"`
	TransactionHashLT           *string  `json:"transactionHashLT,omitempty"`
	TransactionHashLTE          *string  `json:"transactionHashLTE,omitempty"`
	TransactionHashContains     *string  `json:"transactionHashContains,omitempty"`
	TransactionHashHasPrefix    *string  `json:"transactionHashHasPrefix,omitempty"`
	TransactionHashHasSuffix    *string  `json:"transactionHashHasSuffix,omitempty"`
	TransactionHashEqualFold    *string  `json:"transactionHashEqualFold,omitempty"`
	TransactionHashContainsFold *string  `json:"transactionHashContainsFold,omitempty"`

	// "status" field predicates.
	Status      *transactionreceipt.Status  `json:"status,omitempty"`
	StatusNEQ   *transactionreceipt.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []transactionreceipt.Status `json:"statusIn,omitempty"`
	StatusNotIn []transactionreceipt.Status `json:"statusNotIn,omitempty"`

	// "status_data" field predicates.
	StatusData             *string  `json:"statusData,omitempty"`
	StatusDataNEQ          *string  `json:"statusDataNEQ,omitempty"`
	StatusDataIn           []string `json:"statusDataIn,omitempty"`
	StatusDataNotIn        []string `json:"statusDataNotIn,omitempty"`
	StatusDataGT           *string  `json:"statusDataGT,omitempty"`
	StatusDataGTE          *string  `json:"statusDataGTE,omitempty"`
	StatusDataLT           *string  `json:"statusDataLT,omitempty"`
	StatusDataLTE          *string  `json:"statusDataLTE,omitempty"`
	StatusDataContains     *string  `json:"statusDataContains,omitempty"`
	StatusDataHasPrefix    *string  `json:"statusDataHasPrefix,omitempty"`
	StatusDataHasSuffix    *string  `json:"statusDataHasSuffix,omitempty"`
	StatusDataEqualFold    *string  `json:"statusDataEqualFold,omitempty"`
	StatusDataContainsFold *string  `json:"statusDataContainsFold,omitempty"`

	// "block" edge predicates.
	HasBlock     *bool              `json:"hasBlock,omitempty"`
	HasBlockWith []*BlockWhereInput `json:"hasBlockWith,omitempty"`

	// "transaction" edge predicates.
	HasTransaction     *bool                    `json:"hasTransaction,omitempty"`
	HasTransactionWith []*TransactionWhereInput `json:"hasTransactionWith,omitempty"`
}

// Filter applies the TransactionReceiptWhereInput filter on the TransactionReceiptQuery builder.
func (i *TransactionReceiptWhereInput) Filter(q *TransactionReceiptQuery) (*TransactionReceiptQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering transactionreceipts.
// An error is returned if the input is empty or invalid.
func (i *TransactionReceiptWhereInput) P() (predicate.TransactionReceipt, error) {
	var predicates []predicate.TransactionReceipt
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, transactionreceipt.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.TransactionReceipt, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, transactionreceipt.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.TransactionReceipt, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, transactionreceipt.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, transactionreceipt.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, transactionreceipt.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, transactionreceipt.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, transactionreceipt.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, transactionreceipt.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, transactionreceipt.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, transactionreceipt.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, transactionreceipt.IDLTE(*i.IDLTE))
	}
	if i.TransactionHash != nil {
		predicates = append(predicates, transactionreceipt.TransactionHashEQ(*i.TransactionHash))
	}
	if i.TransactionHashNEQ != nil {
		predicates = append(predicates, transactionreceipt.TransactionHashNEQ(*i.TransactionHashNEQ))
	}
	if len(i.TransactionHashIn) > 0 {
		predicates = append(predicates, transactionreceipt.TransactionHashIn(i.TransactionHashIn...))
	}
	if len(i.TransactionHashNotIn) > 0 {
		predicates = append(predicates, transactionreceipt.TransactionHashNotIn(i.TransactionHashNotIn...))
	}
	if i.TransactionHashGT != nil {
		predicates = append(predicates, transactionreceipt.TransactionHashGT(*i.TransactionHashGT))
	}
	if i.TransactionHashGTE != nil {
		predicates = append(predicates, transactionreceipt.TransactionHashGTE(*i.TransactionHashGTE))
	}
	if i.TransactionHashLT != nil {
		predicates = append(predicates, transactionreceipt.TransactionHashLT(*i.TransactionHashLT))
	}
	if i.TransactionHashLTE != nil {
		predicates = append(predicates, transactionreceipt.TransactionHashLTE(*i.TransactionHashLTE))
	}
	if i.TransactionHashContains != nil {
		predicates = append(predicates, transactionreceipt.TransactionHashContains(*i.TransactionHashContains))
	}
	if i.TransactionHashHasPrefix != nil {
		predicates = append(predicates, transactionreceipt.TransactionHashHasPrefix(*i.TransactionHashHasPrefix))
	}
	if i.TransactionHashHasSuffix != nil {
		predicates = append(predicates, transactionreceipt.TransactionHashHasSuffix(*i.TransactionHashHasSuffix))
	}
	if i.TransactionHashEqualFold != nil {
		predicates = append(predicates, transactionreceipt.TransactionHashEqualFold(*i.TransactionHashEqualFold))
	}
	if i.TransactionHashContainsFold != nil {
		predicates = append(predicates, transactionreceipt.TransactionHashContainsFold(*i.TransactionHashContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, transactionreceipt.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, transactionreceipt.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, transactionreceipt.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, transactionreceipt.StatusNotIn(i.StatusNotIn...))
	}
	if i.StatusData != nil {
		predicates = append(predicates, transactionreceipt.StatusDataEQ(*i.StatusData))
	}
	if i.StatusDataNEQ != nil {
		predicates = append(predicates, transactionreceipt.StatusDataNEQ(*i.StatusDataNEQ))
	}
	if len(i.StatusDataIn) > 0 {
		predicates = append(predicates, transactionreceipt.StatusDataIn(i.StatusDataIn...))
	}
	if len(i.StatusDataNotIn) > 0 {
		predicates = append(predicates, transactionreceipt.StatusDataNotIn(i.StatusDataNotIn...))
	}
	if i.StatusDataGT != nil {
		predicates = append(predicates, transactionreceipt.StatusDataGT(*i.StatusDataGT))
	}
	if i.StatusDataGTE != nil {
		predicates = append(predicates, transactionreceipt.StatusDataGTE(*i.StatusDataGTE))
	}
	if i.StatusDataLT != nil {
		predicates = append(predicates, transactionreceipt.StatusDataLT(*i.StatusDataLT))
	}
	if i.StatusDataLTE != nil {
		predicates = append(predicates, transactionreceipt.StatusDataLTE(*i.StatusDataLTE))
	}
	if i.StatusDataContains != nil {
		predicates = append(predicates, transactionreceipt.StatusDataContains(*i.StatusDataContains))
	}
	if i.StatusDataHasPrefix != nil {
		predicates = append(predicates, transactionreceipt.StatusDataHasPrefix(*i.StatusDataHasPrefix))
	}
	if i.StatusDataHasSuffix != nil {
		predicates = append(predicates, transactionreceipt.StatusDataHasSuffix(*i.StatusDataHasSuffix))
	}
	if i.StatusDataEqualFold != nil {
		predicates = append(predicates, transactionreceipt.StatusDataEqualFold(*i.StatusDataEqualFold))
	}
	if i.StatusDataContainsFold != nil {
		predicates = append(predicates, transactionreceipt.StatusDataContainsFold(*i.StatusDataContainsFold))
	}

	if i.HasBlock != nil {
		p := transactionreceipt.HasBlock()
		if !*i.HasBlock {
			p = transactionreceipt.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBlockWith) > 0 {
		with := make([]predicate.Block, 0, len(i.HasBlockWith))
		for _, w := range i.HasBlockWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, transactionreceipt.HasBlockWith(with...))
	}
	if i.HasTransaction != nil {
		p := transactionreceipt.HasTransaction()
		if !*i.HasTransaction {
			p = transactionreceipt.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTransactionWith) > 0 {
		with := make([]predicate.Transaction, 0, len(i.HasTransactionWith))
		for _, w := range i.HasTransactionWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, transactionreceipt.HasTransactionWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("empty predicate TransactionReceiptWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return transactionreceipt.And(predicates...), nil
	}
}
