// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/dontpanicdao/caigo/types"
	"github.com/tarrencev/starknet-indexer/ent/balance"
	"github.com/tarrencev/starknet-indexer/ent/block"
	"github.com/tarrencev/starknet-indexer/ent/contract"
	"github.com/tarrencev/starknet-indexer/ent/event"
	"github.com/tarrencev/starknet-indexer/ent/predicate"
	"github.com/tarrencev/starknet-indexer/ent/token"
	"github.com/tarrencev/starknet-indexer/ent/transaction"
	"github.com/tarrencev/starknet-indexer/ent/transactionreceipt"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeBalance            = "Balance"
	TypeBlock              = "Block"
	TypeContract           = "Contract"
	TypeEvent              = "Event"
	TypeToken              = "Token"
	TypeTransaction        = "Transaction"
	TypeTransactionReceipt = "TransactionReceipt"
)

// BalanceMutation represents an operation that mutates the Balance nodes in the graph.
type BalanceMutation struct {
	config
	op              Op
	typ             string
	id              *string
	balance         *uint64
	addbalance      *int64
	clearedFields   map[string]struct{}
	account         *string
	clearedaccount  bool
	contract        *string
	clearedcontract bool
	done            bool
	oldValue        func(context.Context) (*Balance, error)
	predicates      []predicate.Balance
}

var _ ent.Mutation = (*BalanceMutation)(nil)

// balanceOption allows management of the mutation configuration using functional options.
type balanceOption func(*BalanceMutation)

// newBalanceMutation creates new mutation for the Balance entity.
func newBalanceMutation(c config, op Op, opts ...balanceOption) *BalanceMutation {
	m := &BalanceMutation{
		config:        c,
		op:            op,
		typ:           TypeBalance,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBalanceID sets the ID field of the mutation.
func withBalanceID(id string) balanceOption {
	return func(m *BalanceMutation) {
		var (
			err   error
			once  sync.Once
			value *Balance
		)
		m.oldValue = func(ctx context.Context) (*Balance, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Balance.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBalance sets the old Balance of the mutation.
func withBalance(node *Balance) balanceOption {
	return func(m *BalanceMutation) {
		m.oldValue = func(context.Context) (*Balance, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BalanceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BalanceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Balance entities.
func (m *BalanceMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BalanceMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BalanceMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Balance.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBalance sets the "balance" field.
func (m *BalanceMutation) SetBalance(u uint64) {
	m.balance = &u
	m.addbalance = nil
}

// Balance returns the value of the "balance" field in the mutation.
func (m *BalanceMutation) Balance() (r uint64, exists bool) {
	v := m.balance
	if v == nil {
		return
	}
	return *v, true
}

// OldBalance returns the old "balance" field's value of the Balance entity.
// If the Balance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BalanceMutation) OldBalance(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBalance: %w", err)
	}
	return oldValue.Balance, nil
}

// AddBalance adds u to the "balance" field.
func (m *BalanceMutation) AddBalance(u int64) {
	if m.addbalance != nil {
		*m.addbalance += u
	} else {
		m.addbalance = &u
	}
}

// AddedBalance returns the value that was added to the "balance" field in this mutation.
func (m *BalanceMutation) AddedBalance() (r int64, exists bool) {
	v := m.addbalance
	if v == nil {
		return
	}
	return *v, true
}

// ResetBalance resets all changes to the "balance" field.
func (m *BalanceMutation) ResetBalance() {
	m.balance = nil
	m.addbalance = nil
}

// SetAccountID sets the "account" edge to the Contract entity by id.
func (m *BalanceMutation) SetAccountID(id string) {
	m.account = &id
}

// ClearAccount clears the "account" edge to the Contract entity.
func (m *BalanceMutation) ClearAccount() {
	m.clearedaccount = true
}

// AccountCleared reports if the "account" edge to the Contract entity was cleared.
func (m *BalanceMutation) AccountCleared() bool {
	return m.clearedaccount
}

// AccountID returns the "account" edge ID in the mutation.
func (m *BalanceMutation) AccountID() (id string, exists bool) {
	if m.account != nil {
		return *m.account, true
	}
	return
}

// AccountIDs returns the "account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AccountID instead. It exists only for internal usage by the builders.
func (m *BalanceMutation) AccountIDs() (ids []string) {
	if id := m.account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAccount resets all changes to the "account" edge.
func (m *BalanceMutation) ResetAccount() {
	m.account = nil
	m.clearedaccount = false
}

// SetContractID sets the "contract" edge to the Contract entity by id.
func (m *BalanceMutation) SetContractID(id string) {
	m.contract = &id
}

// ClearContract clears the "contract" edge to the Contract entity.
func (m *BalanceMutation) ClearContract() {
	m.clearedcontract = true
}

// ContractCleared reports if the "contract" edge to the Contract entity was cleared.
func (m *BalanceMutation) ContractCleared() bool {
	return m.clearedcontract
}

// ContractID returns the "contract" edge ID in the mutation.
func (m *BalanceMutation) ContractID() (id string, exists bool) {
	if m.contract != nil {
		return *m.contract, true
	}
	return
}

// ContractIDs returns the "contract" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ContractID instead. It exists only for internal usage by the builders.
func (m *BalanceMutation) ContractIDs() (ids []string) {
	if id := m.contract; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetContract resets all changes to the "contract" edge.
func (m *BalanceMutation) ResetContract() {
	m.contract = nil
	m.clearedcontract = false
}

// Where appends a list predicates to the BalanceMutation builder.
func (m *BalanceMutation) Where(ps ...predicate.Balance) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *BalanceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Balance).
func (m *BalanceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BalanceMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.balance != nil {
		fields = append(fields, balance.FieldBalance)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BalanceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case balance.FieldBalance:
		return m.Balance()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BalanceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case balance.FieldBalance:
		return m.OldBalance(ctx)
	}
	return nil, fmt.Errorf("unknown Balance field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BalanceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case balance.FieldBalance:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBalance(v)
		return nil
	}
	return fmt.Errorf("unknown Balance field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BalanceMutation) AddedFields() []string {
	var fields []string
	if m.addbalance != nil {
		fields = append(fields, balance.FieldBalance)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BalanceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case balance.FieldBalance:
		return m.AddedBalance()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BalanceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case balance.FieldBalance:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBalance(v)
		return nil
	}
	return fmt.Errorf("unknown Balance numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BalanceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BalanceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BalanceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Balance nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BalanceMutation) ResetField(name string) error {
	switch name {
	case balance.FieldBalance:
		m.ResetBalance()
		return nil
	}
	return fmt.Errorf("unknown Balance field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BalanceMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.account != nil {
		edges = append(edges, balance.EdgeAccount)
	}
	if m.contract != nil {
		edges = append(edges, balance.EdgeContract)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BalanceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case balance.EdgeAccount:
		if id := m.account; id != nil {
			return []ent.Value{*id}
		}
	case balance.EdgeContract:
		if id := m.contract; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BalanceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BalanceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BalanceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedaccount {
		edges = append(edges, balance.EdgeAccount)
	}
	if m.clearedcontract {
		edges = append(edges, balance.EdgeContract)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BalanceMutation) EdgeCleared(name string) bool {
	switch name {
	case balance.EdgeAccount:
		return m.clearedaccount
	case balance.EdgeContract:
		return m.clearedcontract
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BalanceMutation) ClearEdge(name string) error {
	switch name {
	case balance.EdgeAccount:
		m.ClearAccount()
		return nil
	case balance.EdgeContract:
		m.ClearContract()
		return nil
	}
	return fmt.Errorf("unknown Balance unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BalanceMutation) ResetEdge(name string) error {
	switch name {
	case balance.EdgeAccount:
		m.ResetAccount()
		return nil
	case balance.EdgeContract:
		m.ResetContract()
		return nil
	}
	return fmt.Errorf("unknown Balance edge %s", name)
}

// BlockMutation represents an operation that mutates the Block nodes in the graph.
type BlockMutation struct {
	config
	op                          Op
	typ                         string
	id                          *string
	block_hash                  *string
	parent_block_hash           *string
	block_number                *uint64
	addblock_number             *int64
	state_root                  *string
	status                      *block.Status
	timestamp                   *time.Time
	clearedFields               map[string]struct{}
	transactions                map[string]struct{}
	removedtransactions         map[string]struct{}
	clearedtransactions         bool
	transaction_receipts        map[string]struct{}
	removedtransaction_receipts map[string]struct{}
	clearedtransaction_receipts bool
	done                        bool
	oldValue                    func(context.Context) (*Block, error)
	predicates                  []predicate.Block
}

var _ ent.Mutation = (*BlockMutation)(nil)

// blockOption allows management of the mutation configuration using functional options.
type blockOption func(*BlockMutation)

// newBlockMutation creates new mutation for the Block entity.
func newBlockMutation(c config, op Op, opts ...blockOption) *BlockMutation {
	m := &BlockMutation{
		config:        c,
		op:            op,
		typ:           TypeBlock,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBlockID sets the ID field of the mutation.
func withBlockID(id string) blockOption {
	return func(m *BlockMutation) {
		var (
			err   error
			once  sync.Once
			value *Block
		)
		m.oldValue = func(ctx context.Context) (*Block, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Block.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBlock sets the old Block of the mutation.
func withBlock(node *Block) blockOption {
	return func(m *BlockMutation) {
		m.oldValue = func(context.Context) (*Block, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BlockMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BlockMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Block entities.
func (m *BlockMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BlockMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BlockMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Block.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBlockHash sets the "block_hash" field.
func (m *BlockMutation) SetBlockHash(s string) {
	m.block_hash = &s
}

// BlockHash returns the value of the "block_hash" field in the mutation.
func (m *BlockMutation) BlockHash() (r string, exists bool) {
	v := m.block_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldBlockHash returns the old "block_hash" field's value of the Block entity.
// If the Block object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockMutation) OldBlockHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlockHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlockHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlockHash: %w", err)
	}
	return oldValue.BlockHash, nil
}

// ResetBlockHash resets all changes to the "block_hash" field.
func (m *BlockMutation) ResetBlockHash() {
	m.block_hash = nil
}

// SetParentBlockHash sets the "parent_block_hash" field.
func (m *BlockMutation) SetParentBlockHash(s string) {
	m.parent_block_hash = &s
}

// ParentBlockHash returns the value of the "parent_block_hash" field in the mutation.
func (m *BlockMutation) ParentBlockHash() (r string, exists bool) {
	v := m.parent_block_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldParentBlockHash returns the old "parent_block_hash" field's value of the Block entity.
// If the Block object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockMutation) OldParentBlockHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentBlockHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentBlockHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentBlockHash: %w", err)
	}
	return oldValue.ParentBlockHash, nil
}

// ResetParentBlockHash resets all changes to the "parent_block_hash" field.
func (m *BlockMutation) ResetParentBlockHash() {
	m.parent_block_hash = nil
}

// SetBlockNumber sets the "block_number" field.
func (m *BlockMutation) SetBlockNumber(u uint64) {
	m.block_number = &u
	m.addblock_number = nil
}

// BlockNumber returns the value of the "block_number" field in the mutation.
func (m *BlockMutation) BlockNumber() (r uint64, exists bool) {
	v := m.block_number
	if v == nil {
		return
	}
	return *v, true
}

// OldBlockNumber returns the old "block_number" field's value of the Block entity.
// If the Block object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockMutation) OldBlockNumber(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlockNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlockNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlockNumber: %w", err)
	}
	return oldValue.BlockNumber, nil
}

// AddBlockNumber adds u to the "block_number" field.
func (m *BlockMutation) AddBlockNumber(u int64) {
	if m.addblock_number != nil {
		*m.addblock_number += u
	} else {
		m.addblock_number = &u
	}
}

// AddedBlockNumber returns the value that was added to the "block_number" field in this mutation.
func (m *BlockMutation) AddedBlockNumber() (r int64, exists bool) {
	v := m.addblock_number
	if v == nil {
		return
	}
	return *v, true
}

// ResetBlockNumber resets all changes to the "block_number" field.
func (m *BlockMutation) ResetBlockNumber() {
	m.block_number = nil
	m.addblock_number = nil
}

// SetStateRoot sets the "state_root" field.
func (m *BlockMutation) SetStateRoot(s string) {
	m.state_root = &s
}

// StateRoot returns the value of the "state_root" field in the mutation.
func (m *BlockMutation) StateRoot() (r string, exists bool) {
	v := m.state_root
	if v == nil {
		return
	}
	return *v, true
}

// OldStateRoot returns the old "state_root" field's value of the Block entity.
// If the Block object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockMutation) OldStateRoot(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStateRoot is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStateRoot requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStateRoot: %w", err)
	}
	return oldValue.StateRoot, nil
}

// ResetStateRoot resets all changes to the "state_root" field.
func (m *BlockMutation) ResetStateRoot() {
	m.state_root = nil
}

// SetStatus sets the "status" field.
func (m *BlockMutation) SetStatus(b block.Status) {
	m.status = &b
}

// Status returns the value of the "status" field in the mutation.
func (m *BlockMutation) Status() (r block.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Block entity.
// If the Block object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockMutation) OldStatus(ctx context.Context) (v block.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *BlockMutation) ResetStatus() {
	m.status = nil
}

// SetTimestamp sets the "timestamp" field.
func (m *BlockMutation) SetTimestamp(t time.Time) {
	m.timestamp = &t
}

// Timestamp returns the value of the "timestamp" field in the mutation.
func (m *BlockMutation) Timestamp() (r time.Time, exists bool) {
	v := m.timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "timestamp" field's value of the Block entity.
// If the Block object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockMutation) OldTimestamp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// ResetTimestamp resets all changes to the "timestamp" field.
func (m *BlockMutation) ResetTimestamp() {
	m.timestamp = nil
}

// AddTransactionIDs adds the "transactions" edge to the Transaction entity by ids.
func (m *BlockMutation) AddTransactionIDs(ids ...string) {
	if m.transactions == nil {
		m.transactions = make(map[string]struct{})
	}
	for i := range ids {
		m.transactions[ids[i]] = struct{}{}
	}
}

// ClearTransactions clears the "transactions" edge to the Transaction entity.
func (m *BlockMutation) ClearTransactions() {
	m.clearedtransactions = true
}

// TransactionsCleared reports if the "transactions" edge to the Transaction entity was cleared.
func (m *BlockMutation) TransactionsCleared() bool {
	return m.clearedtransactions
}

// RemoveTransactionIDs removes the "transactions" edge to the Transaction entity by IDs.
func (m *BlockMutation) RemoveTransactionIDs(ids ...string) {
	if m.removedtransactions == nil {
		m.removedtransactions = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.transactions, ids[i])
		m.removedtransactions[ids[i]] = struct{}{}
	}
}

// RemovedTransactions returns the removed IDs of the "transactions" edge to the Transaction entity.
func (m *BlockMutation) RemovedTransactionsIDs() (ids []string) {
	for id := range m.removedtransactions {
		ids = append(ids, id)
	}
	return
}

// TransactionsIDs returns the "transactions" edge IDs in the mutation.
func (m *BlockMutation) TransactionsIDs() (ids []string) {
	for id := range m.transactions {
		ids = append(ids, id)
	}
	return
}

// ResetTransactions resets all changes to the "transactions" edge.
func (m *BlockMutation) ResetTransactions() {
	m.transactions = nil
	m.clearedtransactions = false
	m.removedtransactions = nil
}

// AddTransactionReceiptIDs adds the "transaction_receipts" edge to the TransactionReceipt entity by ids.
func (m *BlockMutation) AddTransactionReceiptIDs(ids ...string) {
	if m.transaction_receipts == nil {
		m.transaction_receipts = make(map[string]struct{})
	}
	for i := range ids {
		m.transaction_receipts[ids[i]] = struct{}{}
	}
}

// ClearTransactionReceipts clears the "transaction_receipts" edge to the TransactionReceipt entity.
func (m *BlockMutation) ClearTransactionReceipts() {
	m.clearedtransaction_receipts = true
}

// TransactionReceiptsCleared reports if the "transaction_receipts" edge to the TransactionReceipt entity was cleared.
func (m *BlockMutation) TransactionReceiptsCleared() bool {
	return m.clearedtransaction_receipts
}

// RemoveTransactionReceiptIDs removes the "transaction_receipts" edge to the TransactionReceipt entity by IDs.
func (m *BlockMutation) RemoveTransactionReceiptIDs(ids ...string) {
	if m.removedtransaction_receipts == nil {
		m.removedtransaction_receipts = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.transaction_receipts, ids[i])
		m.removedtransaction_receipts[ids[i]] = struct{}{}
	}
}

// RemovedTransactionReceipts returns the removed IDs of the "transaction_receipts" edge to the TransactionReceipt entity.
func (m *BlockMutation) RemovedTransactionReceiptsIDs() (ids []string) {
	for id := range m.removedtransaction_receipts {
		ids = append(ids, id)
	}
	return
}

// TransactionReceiptsIDs returns the "transaction_receipts" edge IDs in the mutation.
func (m *BlockMutation) TransactionReceiptsIDs() (ids []string) {
	for id := range m.transaction_receipts {
		ids = append(ids, id)
	}
	return
}

// ResetTransactionReceipts resets all changes to the "transaction_receipts" edge.
func (m *BlockMutation) ResetTransactionReceipts() {
	m.transaction_receipts = nil
	m.clearedtransaction_receipts = false
	m.removedtransaction_receipts = nil
}

// Where appends a list predicates to the BlockMutation builder.
func (m *BlockMutation) Where(ps ...predicate.Block) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *BlockMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Block).
func (m *BlockMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BlockMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.block_hash != nil {
		fields = append(fields, block.FieldBlockHash)
	}
	if m.parent_block_hash != nil {
		fields = append(fields, block.FieldParentBlockHash)
	}
	if m.block_number != nil {
		fields = append(fields, block.FieldBlockNumber)
	}
	if m.state_root != nil {
		fields = append(fields, block.FieldStateRoot)
	}
	if m.status != nil {
		fields = append(fields, block.FieldStatus)
	}
	if m.timestamp != nil {
		fields = append(fields, block.FieldTimestamp)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BlockMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case block.FieldBlockHash:
		return m.BlockHash()
	case block.FieldParentBlockHash:
		return m.ParentBlockHash()
	case block.FieldBlockNumber:
		return m.BlockNumber()
	case block.FieldStateRoot:
		return m.StateRoot()
	case block.FieldStatus:
		return m.Status()
	case block.FieldTimestamp:
		return m.Timestamp()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BlockMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case block.FieldBlockHash:
		return m.OldBlockHash(ctx)
	case block.FieldParentBlockHash:
		return m.OldParentBlockHash(ctx)
	case block.FieldBlockNumber:
		return m.OldBlockNumber(ctx)
	case block.FieldStateRoot:
		return m.OldStateRoot(ctx)
	case block.FieldStatus:
		return m.OldStatus(ctx)
	case block.FieldTimestamp:
		return m.OldTimestamp(ctx)
	}
	return nil, fmt.Errorf("unknown Block field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlockMutation) SetField(name string, value ent.Value) error {
	switch name {
	case block.FieldBlockHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlockHash(v)
		return nil
	case block.FieldParentBlockHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentBlockHash(v)
		return nil
	case block.FieldBlockNumber:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlockNumber(v)
		return nil
	case block.FieldStateRoot:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStateRoot(v)
		return nil
	case block.FieldStatus:
		v, ok := value.(block.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case block.FieldTimestamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	}
	return fmt.Errorf("unknown Block field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BlockMutation) AddedFields() []string {
	var fields []string
	if m.addblock_number != nil {
		fields = append(fields, block.FieldBlockNumber)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BlockMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case block.FieldBlockNumber:
		return m.AddedBlockNumber()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlockMutation) AddField(name string, value ent.Value) error {
	switch name {
	case block.FieldBlockNumber:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBlockNumber(v)
		return nil
	}
	return fmt.Errorf("unknown Block numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BlockMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BlockMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BlockMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Block nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BlockMutation) ResetField(name string) error {
	switch name {
	case block.FieldBlockHash:
		m.ResetBlockHash()
		return nil
	case block.FieldParentBlockHash:
		m.ResetParentBlockHash()
		return nil
	case block.FieldBlockNumber:
		m.ResetBlockNumber()
		return nil
	case block.FieldStateRoot:
		m.ResetStateRoot()
		return nil
	case block.FieldStatus:
		m.ResetStatus()
		return nil
	case block.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	}
	return fmt.Errorf("unknown Block field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BlockMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.transactions != nil {
		edges = append(edges, block.EdgeTransactions)
	}
	if m.transaction_receipts != nil {
		edges = append(edges, block.EdgeTransactionReceipts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BlockMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case block.EdgeTransactions:
		ids := make([]ent.Value, 0, len(m.transactions))
		for id := range m.transactions {
			ids = append(ids, id)
		}
		return ids
	case block.EdgeTransactionReceipts:
		ids := make([]ent.Value, 0, len(m.transaction_receipts))
		for id := range m.transaction_receipts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BlockMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtransactions != nil {
		edges = append(edges, block.EdgeTransactions)
	}
	if m.removedtransaction_receipts != nil {
		edges = append(edges, block.EdgeTransactionReceipts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BlockMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case block.EdgeTransactions:
		ids := make([]ent.Value, 0, len(m.removedtransactions))
		for id := range m.removedtransactions {
			ids = append(ids, id)
		}
		return ids
	case block.EdgeTransactionReceipts:
		ids := make([]ent.Value, 0, len(m.removedtransaction_receipts))
		for id := range m.removedtransaction_receipts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BlockMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtransactions {
		edges = append(edges, block.EdgeTransactions)
	}
	if m.clearedtransaction_receipts {
		edges = append(edges, block.EdgeTransactionReceipts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BlockMutation) EdgeCleared(name string) bool {
	switch name {
	case block.EdgeTransactions:
		return m.clearedtransactions
	case block.EdgeTransactionReceipts:
		return m.clearedtransaction_receipts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BlockMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Block unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BlockMutation) ResetEdge(name string) error {
	switch name {
	case block.EdgeTransactions:
		m.ResetTransactions()
		return nil
	case block.EdgeTransactionReceipts:
		m.ResetTransactionReceipts()
		return nil
	}
	return fmt.Errorf("unknown Block edge %s", name)
}

// ContractMutation represents an operation that mutates the Contract nodes in the graph.
type ContractMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	_type               *contract.Type
	created_at          *time.Time
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	transactions        map[string]struct{}
	removedtransactions map[string]struct{}
	clearedtransactions bool
	done                bool
	oldValue            func(context.Context) (*Contract, error)
	predicates          []predicate.Contract
}

var _ ent.Mutation = (*ContractMutation)(nil)

// contractOption allows management of the mutation configuration using functional options.
type contractOption func(*ContractMutation)

// newContractMutation creates new mutation for the Contract entity.
func newContractMutation(c config, op Op, opts ...contractOption) *ContractMutation {
	m := &ContractMutation{
		config:        c,
		op:            op,
		typ:           TypeContract,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withContractID sets the ID field of the mutation.
func withContractID(id string) contractOption {
	return func(m *ContractMutation) {
		var (
			err   error
			once  sync.Once
			value *Contract
		)
		m.oldValue = func(ctx context.Context) (*Contract, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Contract.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withContract sets the old Contract of the mutation.
func withContract(node *Contract) contractOption {
	return func(m *ContractMutation) {
		m.oldValue = func(context.Context) (*Contract, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ContractMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ContractMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Contract entities.
func (m *ContractMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ContractMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ContractMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Contract.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetType sets the "type" field.
func (m *ContractMutation) SetType(c contract.Type) {
	m._type = &c
}

// GetType returns the value of the "type" field in the mutation.
func (m *ContractMutation) GetType() (r contract.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldType(ctx context.Context) (v contract.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ContractMutation) ResetType() {
	m._type = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ContractMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ContractMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ContractMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ContractMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ContractMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ContractMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddTransactionIDs adds the "transactions" edge to the Transaction entity by ids.
func (m *ContractMutation) AddTransactionIDs(ids ...string) {
	if m.transactions == nil {
		m.transactions = make(map[string]struct{})
	}
	for i := range ids {
		m.transactions[ids[i]] = struct{}{}
	}
}

// ClearTransactions clears the "transactions" edge to the Transaction entity.
func (m *ContractMutation) ClearTransactions() {
	m.clearedtransactions = true
}

// TransactionsCleared reports if the "transactions" edge to the Transaction entity was cleared.
func (m *ContractMutation) TransactionsCleared() bool {
	return m.clearedtransactions
}

// RemoveTransactionIDs removes the "transactions" edge to the Transaction entity by IDs.
func (m *ContractMutation) RemoveTransactionIDs(ids ...string) {
	if m.removedtransactions == nil {
		m.removedtransactions = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.transactions, ids[i])
		m.removedtransactions[ids[i]] = struct{}{}
	}
}

// RemovedTransactions returns the removed IDs of the "transactions" edge to the Transaction entity.
func (m *ContractMutation) RemovedTransactionsIDs() (ids []string) {
	for id := range m.removedtransactions {
		ids = append(ids, id)
	}
	return
}

// TransactionsIDs returns the "transactions" edge IDs in the mutation.
func (m *ContractMutation) TransactionsIDs() (ids []string) {
	for id := range m.transactions {
		ids = append(ids, id)
	}
	return
}

// ResetTransactions resets all changes to the "transactions" edge.
func (m *ContractMutation) ResetTransactions() {
	m.transactions = nil
	m.clearedtransactions = false
	m.removedtransactions = nil
}

// Where appends a list predicates to the ContractMutation builder.
func (m *ContractMutation) Where(ps ...predicate.Contract) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ContractMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Contract).
func (m *ContractMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ContractMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m._type != nil {
		fields = append(fields, contract.FieldType)
	}
	if m.created_at != nil {
		fields = append(fields, contract.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, contract.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ContractMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case contract.FieldType:
		return m.GetType()
	case contract.FieldCreatedAt:
		return m.CreatedAt()
	case contract.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ContractMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case contract.FieldType:
		return m.OldType(ctx)
	case contract.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case contract.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Contract field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContractMutation) SetField(name string, value ent.Value) error {
	switch name {
	case contract.FieldType:
		v, ok := value.(contract.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case contract.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case contract.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Contract field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ContractMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ContractMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContractMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Contract numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ContractMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ContractMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ContractMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Contract nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ContractMutation) ResetField(name string) error {
	switch name {
	case contract.FieldType:
		m.ResetType()
		return nil
	case contract.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case contract.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Contract field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ContractMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.transactions != nil {
		edges = append(edges, contract.EdgeTransactions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ContractMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case contract.EdgeTransactions:
		ids := make([]ent.Value, 0, len(m.transactions))
		for id := range m.transactions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ContractMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedtransactions != nil {
		edges = append(edges, contract.EdgeTransactions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ContractMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case contract.EdgeTransactions:
		ids := make([]ent.Value, 0, len(m.removedtransactions))
		for id := range m.removedtransactions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ContractMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtransactions {
		edges = append(edges, contract.EdgeTransactions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ContractMutation) EdgeCleared(name string) bool {
	switch name {
	case contract.EdgeTransactions:
		return m.clearedtransactions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ContractMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Contract unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ContractMutation) ResetEdge(name string) error {
	switch name {
	case contract.EdgeTransactions:
		m.ResetTransactions()
		return nil
	}
	return fmt.Errorf("unknown Contract edge %s", name)
}

// EventMutation represents an operation that mutates the Event nodes in the graph.
type EventMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	from               *string
	keys               *[]*types.Felt
	data               *[]*types.Felt
	clearedFields      map[string]struct{}
	transaction        *string
	clearedtransaction bool
	done               bool
	oldValue           func(context.Context) (*Event, error)
	predicates         []predicate.Event
}

var _ ent.Mutation = (*EventMutation)(nil)

// eventOption allows management of the mutation configuration using functional options.
type eventOption func(*EventMutation)

// newEventMutation creates new mutation for the Event entity.
func newEventMutation(c config, op Op, opts ...eventOption) *EventMutation {
	m := &EventMutation{
		config:        c,
		op:            op,
		typ:           TypeEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEventID sets the ID field of the mutation.
func withEventID(id string) eventOption {
	return func(m *EventMutation) {
		var (
			err   error
			once  sync.Once
			value *Event
		)
		m.oldValue = func(ctx context.Context) (*Event, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Event.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEvent sets the old Event of the mutation.
func withEvent(node *Event) eventOption {
	return func(m *EventMutation) {
		m.oldValue = func(context.Context) (*Event, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Event entities.
func (m *EventMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EventMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EventMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Event.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFrom sets the "from" field.
func (m *EventMutation) SetFrom(s string) {
	m.from = &s
}

// From returns the value of the "from" field in the mutation.
func (m *EventMutation) From() (r string, exists bool) {
	v := m.from
	if v == nil {
		return
	}
	return *v, true
}

// OldFrom returns the old "from" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldFrom(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFrom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFrom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFrom: %w", err)
	}
	return oldValue.From, nil
}

// ResetFrom resets all changes to the "from" field.
func (m *EventMutation) ResetFrom() {
	m.from = nil
}

// SetKeys sets the "keys" field.
func (m *EventMutation) SetKeys(t []*types.Felt) {
	m.keys = &t
}

// Keys returns the value of the "keys" field in the mutation.
func (m *EventMutation) Keys() (r []*types.Felt, exists bool) {
	v := m.keys
	if v == nil {
		return
	}
	return *v, true
}

// OldKeys returns the old "keys" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldKeys(ctx context.Context) (v []*types.Felt, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeys is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeys requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeys: %w", err)
	}
	return oldValue.Keys, nil
}

// ResetKeys resets all changes to the "keys" field.
func (m *EventMutation) ResetKeys() {
	m.keys = nil
}

// SetData sets the "data" field.
func (m *EventMutation) SetData(t []*types.Felt) {
	m.data = &t
}

// Data returns the value of the "data" field in the mutation.
func (m *EventMutation) Data() (r []*types.Felt, exists bool) {
	v := m.data
	if v == nil {
		return
	}
	return *v, true
}

// OldData returns the old "data" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldData(ctx context.Context) (v []*types.Felt, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldData: %w", err)
	}
	return oldValue.Data, nil
}

// ResetData resets all changes to the "data" field.
func (m *EventMutation) ResetData() {
	m.data = nil
}

// SetTransactionID sets the "transaction" edge to the Transaction entity by id.
func (m *EventMutation) SetTransactionID(id string) {
	m.transaction = &id
}

// ClearTransaction clears the "transaction" edge to the Transaction entity.
func (m *EventMutation) ClearTransaction() {
	m.clearedtransaction = true
}

// TransactionCleared reports if the "transaction" edge to the Transaction entity was cleared.
func (m *EventMutation) TransactionCleared() bool {
	return m.clearedtransaction
}

// TransactionID returns the "transaction" edge ID in the mutation.
func (m *EventMutation) TransactionID() (id string, exists bool) {
	if m.transaction != nil {
		return *m.transaction, true
	}
	return
}

// TransactionIDs returns the "transaction" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TransactionID instead. It exists only for internal usage by the builders.
func (m *EventMutation) TransactionIDs() (ids []string) {
	if id := m.transaction; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTransaction resets all changes to the "transaction" edge.
func (m *EventMutation) ResetTransaction() {
	m.transaction = nil
	m.clearedtransaction = false
}

// Where appends a list predicates to the EventMutation builder.
func (m *EventMutation) Where(ps ...predicate.Event) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *EventMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Event).
func (m *EventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EventMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.from != nil {
		fields = append(fields, event.FieldFrom)
	}
	if m.keys != nil {
		fields = append(fields, event.FieldKeys)
	}
	if m.data != nil {
		fields = append(fields, event.FieldData)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case event.FieldFrom:
		return m.From()
	case event.FieldKeys:
		return m.Keys()
	case event.FieldData:
		return m.Data()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case event.FieldFrom:
		return m.OldFrom(ctx)
	case event.FieldKeys:
		return m.OldKeys(ctx)
	case event.FieldData:
		return m.OldData(ctx)
	}
	return nil, fmt.Errorf("unknown Event field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case event.FieldFrom:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFrom(v)
		return nil
	case event.FieldKeys:
		v, ok := value.([]*types.Felt)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeys(v)
		return nil
	case event.FieldData:
		v, ok := value.([]*types.Felt)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetData(v)
		return nil
	}
	return fmt.Errorf("unknown Event field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EventMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EventMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Event numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EventMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EventMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Event nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EventMutation) ResetField(name string) error {
	switch name {
	case event.FieldFrom:
		m.ResetFrom()
		return nil
	case event.FieldKeys:
		m.ResetKeys()
		return nil
	case event.FieldData:
		m.ResetData()
		return nil
	}
	return fmt.Errorf("unknown Event field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EventMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.transaction != nil {
		edges = append(edges, event.EdgeTransaction)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EventMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case event.EdgeTransaction:
		if id := m.transaction; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EventMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtransaction {
		edges = append(edges, event.EdgeTransaction)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EventMutation) EdgeCleared(name string) bool {
	switch name {
	case event.EdgeTransaction:
		return m.clearedtransaction
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EventMutation) ClearEdge(name string) error {
	switch name {
	case event.EdgeTransaction:
		m.ClearTransaction()
		return nil
	}
	return fmt.Errorf("unknown Event unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EventMutation) ResetEdge(name string) error {
	switch name {
	case event.EdgeTransaction:
		m.ResetTransaction()
		return nil
	}
	return fmt.Errorf("unknown Event edge %s", name)
}

// TokenMutation represents an operation that mutates the Token nodes in the graph.
type TokenMutation struct {
	config
	op              Op
	typ             string
	id              *string
	tokenId         *uint64
	addtokenId      *int64
	clearedFields   map[string]struct{}
	owner           *string
	clearedowner    bool
	contract        *string
	clearedcontract bool
	done            bool
	oldValue        func(context.Context) (*Token, error)
	predicates      []predicate.Token
}

var _ ent.Mutation = (*TokenMutation)(nil)

// tokenOption allows management of the mutation configuration using functional options.
type tokenOption func(*TokenMutation)

// newTokenMutation creates new mutation for the Token entity.
func newTokenMutation(c config, op Op, opts ...tokenOption) *TokenMutation {
	m := &TokenMutation{
		config:        c,
		op:            op,
		typ:           TypeToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTokenID sets the ID field of the mutation.
func withTokenID(id string) tokenOption {
	return func(m *TokenMutation) {
		var (
			err   error
			once  sync.Once
			value *Token
		)
		m.oldValue = func(ctx context.Context) (*Token, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Token.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withToken sets the old Token of the mutation.
func withToken(node *Token) tokenOption {
	return func(m *TokenMutation) {
		m.oldValue = func(context.Context) (*Token, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Token entities.
func (m *TokenMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TokenMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TokenMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Token.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTokenId sets the "tokenId" field.
func (m *TokenMutation) SetTokenId(u uint64) {
	m.tokenId = &u
	m.addtokenId = nil
}

// TokenId returns the value of the "tokenId" field in the mutation.
func (m *TokenMutation) TokenId() (r uint64, exists bool) {
	v := m.tokenId
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenId returns the old "tokenId" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldTokenId(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenId: %w", err)
	}
	return oldValue.TokenId, nil
}

// AddTokenId adds u to the "tokenId" field.
func (m *TokenMutation) AddTokenId(u int64) {
	if m.addtokenId != nil {
		*m.addtokenId += u
	} else {
		m.addtokenId = &u
	}
}

// AddedTokenId returns the value that was added to the "tokenId" field in this mutation.
func (m *TokenMutation) AddedTokenId() (r int64, exists bool) {
	v := m.addtokenId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTokenId resets all changes to the "tokenId" field.
func (m *TokenMutation) ResetTokenId() {
	m.tokenId = nil
	m.addtokenId = nil
}

// SetOwnerID sets the "owner" edge to the Contract entity by id.
func (m *TokenMutation) SetOwnerID(id string) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the Contract entity.
func (m *TokenMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the Contract entity was cleared.
func (m *TokenMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *TokenMutation) OwnerID() (id string, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *TokenMutation) OwnerIDs() (ids []string) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *TokenMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// SetContractID sets the "contract" edge to the Contract entity by id.
func (m *TokenMutation) SetContractID(id string) {
	m.contract = &id
}

// ClearContract clears the "contract" edge to the Contract entity.
func (m *TokenMutation) ClearContract() {
	m.clearedcontract = true
}

// ContractCleared reports if the "contract" edge to the Contract entity was cleared.
func (m *TokenMutation) ContractCleared() bool {
	return m.clearedcontract
}

// ContractID returns the "contract" edge ID in the mutation.
func (m *TokenMutation) ContractID() (id string, exists bool) {
	if m.contract != nil {
		return *m.contract, true
	}
	return
}

// ContractIDs returns the "contract" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ContractID instead. It exists only for internal usage by the builders.
func (m *TokenMutation) ContractIDs() (ids []string) {
	if id := m.contract; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetContract resets all changes to the "contract" edge.
func (m *TokenMutation) ResetContract() {
	m.contract = nil
	m.clearedcontract = false
}

// Where appends a list predicates to the TokenMutation builder.
func (m *TokenMutation) Where(ps ...predicate.Token) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TokenMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Token).
func (m *TokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TokenMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.tokenId != nil {
		fields = append(fields, token.FieldTokenId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case token.FieldTokenId:
		return m.TokenId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case token.FieldTokenId:
		return m.OldTokenId(ctx)
	}
	return nil, fmt.Errorf("unknown Token field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case token.FieldTokenId:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenId(v)
		return nil
	}
	return fmt.Errorf("unknown Token field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TokenMutation) AddedFields() []string {
	var fields []string
	if m.addtokenId != nil {
		fields = append(fields, token.FieldTokenId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TokenMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case token.FieldTokenId:
		return m.AddedTokenId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	case token.FieldTokenId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTokenId(v)
		return nil
	}
	return fmt.Errorf("unknown Token numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TokenMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TokenMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Token nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TokenMutation) ResetField(name string) error {
	switch name {
	case token.FieldTokenId:
		m.ResetTokenId()
		return nil
	}
	return fmt.Errorf("unknown Token field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.owner != nil {
		edges = append(edges, token.EdgeOwner)
	}
	if m.contract != nil {
		edges = append(edges, token.EdgeContract)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TokenMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case token.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case token.EdgeContract:
		if id := m.contract; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TokenMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedowner {
		edges = append(edges, token.EdgeOwner)
	}
	if m.clearedcontract {
		edges = append(edges, token.EdgeContract)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TokenMutation) EdgeCleared(name string) bool {
	switch name {
	case token.EdgeOwner:
		return m.clearedowner
	case token.EdgeContract:
		return m.clearedcontract
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TokenMutation) ClearEdge(name string) error {
	switch name {
	case token.EdgeOwner:
		m.ClearOwner()
		return nil
	case token.EdgeContract:
		m.ClearContract()
		return nil
	}
	return fmt.Errorf("unknown Token unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TokenMutation) ResetEdge(name string) error {
	switch name {
	case token.EdgeOwner:
		m.ResetOwner()
		return nil
	case token.EdgeContract:
		m.ResetContract()
		return nil
	}
	return fmt.Errorf("unknown Token edge %s", name)
}

// TransactionMutation represents an operation that mutates the Transaction nodes in the graph.
type TransactionMutation struct {
	config
	op                   Op
	typ                  string
	id                   *string
	contract_address     *string
	entry_point_selector *string
	transaction_hash     *string
	calldata             *[]string
	signature            *[]string
	nonce                *string
	clearedFields        map[string]struct{}
	block                *string
	clearedblock         bool
	receipt              *string
	clearedreceipt       bool
	events               map[string]struct{}
	removedevents        map[string]struct{}
	clearedevents        bool
	done                 bool
	oldValue             func(context.Context) (*Transaction, error)
	predicates           []predicate.Transaction
}

var _ ent.Mutation = (*TransactionMutation)(nil)

// transactionOption allows management of the mutation configuration using functional options.
type transactionOption func(*TransactionMutation)

// newTransactionMutation creates new mutation for the Transaction entity.
func newTransactionMutation(c config, op Op, opts ...transactionOption) *TransactionMutation {
	m := &TransactionMutation{
		config:        c,
		op:            op,
		typ:           TypeTransaction,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTransactionID sets the ID field of the mutation.
func withTransactionID(id string) transactionOption {
	return func(m *TransactionMutation) {
		var (
			err   error
			once  sync.Once
			value *Transaction
		)
		m.oldValue = func(ctx context.Context) (*Transaction, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Transaction.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTransaction sets the old Transaction of the mutation.
func withTransaction(node *Transaction) transactionOption {
	return func(m *TransactionMutation) {
		m.oldValue = func(context.Context) (*Transaction, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TransactionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TransactionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Transaction entities.
func (m *TransactionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TransactionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TransactionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Transaction.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetContractAddress sets the "contract_address" field.
func (m *TransactionMutation) SetContractAddress(s string) {
	m.contract_address = &s
}

// ContractAddress returns the value of the "contract_address" field in the mutation.
func (m *TransactionMutation) ContractAddress() (r string, exists bool) {
	v := m.contract_address
	if v == nil {
		return
	}
	return *v, true
}

// OldContractAddress returns the old "contract_address" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldContractAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContractAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContractAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContractAddress: %w", err)
	}
	return oldValue.ContractAddress, nil
}

// ResetContractAddress resets all changes to the "contract_address" field.
func (m *TransactionMutation) ResetContractAddress() {
	m.contract_address = nil
}

// SetEntryPointSelector sets the "entry_point_selector" field.
func (m *TransactionMutation) SetEntryPointSelector(s string) {
	m.entry_point_selector = &s
}

// EntryPointSelector returns the value of the "entry_point_selector" field in the mutation.
func (m *TransactionMutation) EntryPointSelector() (r string, exists bool) {
	v := m.entry_point_selector
	if v == nil {
		return
	}
	return *v, true
}

// OldEntryPointSelector returns the old "entry_point_selector" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldEntryPointSelector(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntryPointSelector is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntryPointSelector requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntryPointSelector: %w", err)
	}
	return oldValue.EntryPointSelector, nil
}

// ClearEntryPointSelector clears the value of the "entry_point_selector" field.
func (m *TransactionMutation) ClearEntryPointSelector() {
	m.entry_point_selector = nil
	m.clearedFields[transaction.FieldEntryPointSelector] = struct{}{}
}

// EntryPointSelectorCleared returns if the "entry_point_selector" field was cleared in this mutation.
func (m *TransactionMutation) EntryPointSelectorCleared() bool {
	_, ok := m.clearedFields[transaction.FieldEntryPointSelector]
	return ok
}

// ResetEntryPointSelector resets all changes to the "entry_point_selector" field.
func (m *TransactionMutation) ResetEntryPointSelector() {
	m.entry_point_selector = nil
	delete(m.clearedFields, transaction.FieldEntryPointSelector)
}

// SetTransactionHash sets the "transaction_hash" field.
func (m *TransactionMutation) SetTransactionHash(s string) {
	m.transaction_hash = &s
}

// TransactionHash returns the value of the "transaction_hash" field in the mutation.
func (m *TransactionMutation) TransactionHash() (r string, exists bool) {
	v := m.transaction_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldTransactionHash returns the old "transaction_hash" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldTransactionHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransactionHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransactionHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransactionHash: %w", err)
	}
	return oldValue.TransactionHash, nil
}

// ResetTransactionHash resets all changes to the "transaction_hash" field.
func (m *TransactionMutation) ResetTransactionHash() {
	m.transaction_hash = nil
}

// SetCalldata sets the "calldata" field.
func (m *TransactionMutation) SetCalldata(s []string) {
	m.calldata = &s
}

// Calldata returns the value of the "calldata" field in the mutation.
func (m *TransactionMutation) Calldata() (r []string, exists bool) {
	v := m.calldata
	if v == nil {
		return
	}
	return *v, true
}

// OldCalldata returns the old "calldata" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldCalldata(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCalldata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCalldata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCalldata: %w", err)
	}
	return oldValue.Calldata, nil
}

// ResetCalldata resets all changes to the "calldata" field.
func (m *TransactionMutation) ResetCalldata() {
	m.calldata = nil
}

// SetSignature sets the "signature" field.
func (m *TransactionMutation) SetSignature(s []string) {
	m.signature = &s
}

// Signature returns the value of the "signature" field in the mutation.
func (m *TransactionMutation) Signature() (r []string, exists bool) {
	v := m.signature
	if v == nil {
		return
	}
	return *v, true
}

// OldSignature returns the old "signature" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldSignature(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignature is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignature requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignature: %w", err)
	}
	return oldValue.Signature, nil
}

// ClearSignature clears the value of the "signature" field.
func (m *TransactionMutation) ClearSignature() {
	m.signature = nil
	m.clearedFields[transaction.FieldSignature] = struct{}{}
}

// SignatureCleared returns if the "signature" field was cleared in this mutation.
func (m *TransactionMutation) SignatureCleared() bool {
	_, ok := m.clearedFields[transaction.FieldSignature]
	return ok
}

// ResetSignature resets all changes to the "signature" field.
func (m *TransactionMutation) ResetSignature() {
	m.signature = nil
	delete(m.clearedFields, transaction.FieldSignature)
}

// SetNonce sets the "nonce" field.
func (m *TransactionMutation) SetNonce(s string) {
	m.nonce = &s
}

// Nonce returns the value of the "nonce" field in the mutation.
func (m *TransactionMutation) Nonce() (r string, exists bool) {
	v := m.nonce
	if v == nil {
		return
	}
	return *v, true
}

// OldNonce returns the old "nonce" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldNonce(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNonce is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNonce requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNonce: %w", err)
	}
	return oldValue.Nonce, nil
}

// ClearNonce clears the value of the "nonce" field.
func (m *TransactionMutation) ClearNonce() {
	m.nonce = nil
	m.clearedFields[transaction.FieldNonce] = struct{}{}
}

// NonceCleared returns if the "nonce" field was cleared in this mutation.
func (m *TransactionMutation) NonceCleared() bool {
	_, ok := m.clearedFields[transaction.FieldNonce]
	return ok
}

// ResetNonce resets all changes to the "nonce" field.
func (m *TransactionMutation) ResetNonce() {
	m.nonce = nil
	delete(m.clearedFields, transaction.FieldNonce)
}

// SetBlockID sets the "block" edge to the Block entity by id.
func (m *TransactionMutation) SetBlockID(id string) {
	m.block = &id
}

// ClearBlock clears the "block" edge to the Block entity.
func (m *TransactionMutation) ClearBlock() {
	m.clearedblock = true
}

// BlockCleared reports if the "block" edge to the Block entity was cleared.
func (m *TransactionMutation) BlockCleared() bool {
	return m.clearedblock
}

// BlockID returns the "block" edge ID in the mutation.
func (m *TransactionMutation) BlockID() (id string, exists bool) {
	if m.block != nil {
		return *m.block, true
	}
	return
}

// BlockIDs returns the "block" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BlockID instead. It exists only for internal usage by the builders.
func (m *TransactionMutation) BlockIDs() (ids []string) {
	if id := m.block; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBlock resets all changes to the "block" edge.
func (m *TransactionMutation) ResetBlock() {
	m.block = nil
	m.clearedblock = false
}

// SetReceiptID sets the "receipt" edge to the TransactionReceipt entity by id.
func (m *TransactionMutation) SetReceiptID(id string) {
	m.receipt = &id
}

// ClearReceipt clears the "receipt" edge to the TransactionReceipt entity.
func (m *TransactionMutation) ClearReceipt() {
	m.clearedreceipt = true
}

// ReceiptCleared reports if the "receipt" edge to the TransactionReceipt entity was cleared.
func (m *TransactionMutation) ReceiptCleared() bool {
	return m.clearedreceipt
}

// ReceiptID returns the "receipt" edge ID in the mutation.
func (m *TransactionMutation) ReceiptID() (id string, exists bool) {
	if m.receipt != nil {
		return *m.receipt, true
	}
	return
}

// ReceiptIDs returns the "receipt" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReceiptID instead. It exists only for internal usage by the builders.
func (m *TransactionMutation) ReceiptIDs() (ids []string) {
	if id := m.receipt; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetReceipt resets all changes to the "receipt" edge.
func (m *TransactionMutation) ResetReceipt() {
	m.receipt = nil
	m.clearedreceipt = false
}

// AddEventIDs adds the "events" edge to the Event entity by ids.
func (m *TransactionMutation) AddEventIDs(ids ...string) {
	if m.events == nil {
		m.events = make(map[string]struct{})
	}
	for i := range ids {
		m.events[ids[i]] = struct{}{}
	}
}

// ClearEvents clears the "events" edge to the Event entity.
func (m *TransactionMutation) ClearEvents() {
	m.clearedevents = true
}

// EventsCleared reports if the "events" edge to the Event entity was cleared.
func (m *TransactionMutation) EventsCleared() bool {
	return m.clearedevents
}

// RemoveEventIDs removes the "events" edge to the Event entity by IDs.
func (m *TransactionMutation) RemoveEventIDs(ids ...string) {
	if m.removedevents == nil {
		m.removedevents = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.events, ids[i])
		m.removedevents[ids[i]] = struct{}{}
	}
}

// RemovedEvents returns the removed IDs of the "events" edge to the Event entity.
func (m *TransactionMutation) RemovedEventsIDs() (ids []string) {
	for id := range m.removedevents {
		ids = append(ids, id)
	}
	return
}

// EventsIDs returns the "events" edge IDs in the mutation.
func (m *TransactionMutation) EventsIDs() (ids []string) {
	for id := range m.events {
		ids = append(ids, id)
	}
	return
}

// ResetEvents resets all changes to the "events" edge.
func (m *TransactionMutation) ResetEvents() {
	m.events = nil
	m.clearedevents = false
	m.removedevents = nil
}

// Where appends a list predicates to the TransactionMutation builder.
func (m *TransactionMutation) Where(ps ...predicate.Transaction) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TransactionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Transaction).
func (m *TransactionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TransactionMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.contract_address != nil {
		fields = append(fields, transaction.FieldContractAddress)
	}
	if m.entry_point_selector != nil {
		fields = append(fields, transaction.FieldEntryPointSelector)
	}
	if m.transaction_hash != nil {
		fields = append(fields, transaction.FieldTransactionHash)
	}
	if m.calldata != nil {
		fields = append(fields, transaction.FieldCalldata)
	}
	if m.signature != nil {
		fields = append(fields, transaction.FieldSignature)
	}
	if m.nonce != nil {
		fields = append(fields, transaction.FieldNonce)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TransactionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case transaction.FieldContractAddress:
		return m.ContractAddress()
	case transaction.FieldEntryPointSelector:
		return m.EntryPointSelector()
	case transaction.FieldTransactionHash:
		return m.TransactionHash()
	case transaction.FieldCalldata:
		return m.Calldata()
	case transaction.FieldSignature:
		return m.Signature()
	case transaction.FieldNonce:
		return m.Nonce()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TransactionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case transaction.FieldContractAddress:
		return m.OldContractAddress(ctx)
	case transaction.FieldEntryPointSelector:
		return m.OldEntryPointSelector(ctx)
	case transaction.FieldTransactionHash:
		return m.OldTransactionHash(ctx)
	case transaction.FieldCalldata:
		return m.OldCalldata(ctx)
	case transaction.FieldSignature:
		return m.OldSignature(ctx)
	case transaction.FieldNonce:
		return m.OldNonce(ctx)
	}
	return nil, fmt.Errorf("unknown Transaction field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case transaction.FieldContractAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContractAddress(v)
		return nil
	case transaction.FieldEntryPointSelector:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntryPointSelector(v)
		return nil
	case transaction.FieldTransactionHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransactionHash(v)
		return nil
	case transaction.FieldCalldata:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCalldata(v)
		return nil
	case transaction.FieldSignature:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignature(v)
		return nil
	case transaction.FieldNonce:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNonce(v)
		return nil
	}
	return fmt.Errorf("unknown Transaction field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TransactionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TransactionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Transaction numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TransactionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(transaction.FieldEntryPointSelector) {
		fields = append(fields, transaction.FieldEntryPointSelector)
	}
	if m.FieldCleared(transaction.FieldSignature) {
		fields = append(fields, transaction.FieldSignature)
	}
	if m.FieldCleared(transaction.FieldNonce) {
		fields = append(fields, transaction.FieldNonce)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TransactionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TransactionMutation) ClearField(name string) error {
	switch name {
	case transaction.FieldEntryPointSelector:
		m.ClearEntryPointSelector()
		return nil
	case transaction.FieldSignature:
		m.ClearSignature()
		return nil
	case transaction.FieldNonce:
		m.ClearNonce()
		return nil
	}
	return fmt.Errorf("unknown Transaction nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TransactionMutation) ResetField(name string) error {
	switch name {
	case transaction.FieldContractAddress:
		m.ResetContractAddress()
		return nil
	case transaction.FieldEntryPointSelector:
		m.ResetEntryPointSelector()
		return nil
	case transaction.FieldTransactionHash:
		m.ResetTransactionHash()
		return nil
	case transaction.FieldCalldata:
		m.ResetCalldata()
		return nil
	case transaction.FieldSignature:
		m.ResetSignature()
		return nil
	case transaction.FieldNonce:
		m.ResetNonce()
		return nil
	}
	return fmt.Errorf("unknown Transaction field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TransactionMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.block != nil {
		edges = append(edges, transaction.EdgeBlock)
	}
	if m.receipt != nil {
		edges = append(edges, transaction.EdgeReceipt)
	}
	if m.events != nil {
		edges = append(edges, transaction.EdgeEvents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TransactionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case transaction.EdgeBlock:
		if id := m.block; id != nil {
			return []ent.Value{*id}
		}
	case transaction.EdgeReceipt:
		if id := m.receipt; id != nil {
			return []ent.Value{*id}
		}
	case transaction.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.events))
		for id := range m.events {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TransactionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedevents != nil {
		edges = append(edges, transaction.EdgeEvents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TransactionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case transaction.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.removedevents))
		for id := range m.removedevents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TransactionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedblock {
		edges = append(edges, transaction.EdgeBlock)
	}
	if m.clearedreceipt {
		edges = append(edges, transaction.EdgeReceipt)
	}
	if m.clearedevents {
		edges = append(edges, transaction.EdgeEvents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TransactionMutation) EdgeCleared(name string) bool {
	switch name {
	case transaction.EdgeBlock:
		return m.clearedblock
	case transaction.EdgeReceipt:
		return m.clearedreceipt
	case transaction.EdgeEvents:
		return m.clearedevents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TransactionMutation) ClearEdge(name string) error {
	switch name {
	case transaction.EdgeBlock:
		m.ClearBlock()
		return nil
	case transaction.EdgeReceipt:
		m.ClearReceipt()
		return nil
	}
	return fmt.Errorf("unknown Transaction unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TransactionMutation) ResetEdge(name string) error {
	switch name {
	case transaction.EdgeBlock:
		m.ResetBlock()
		return nil
	case transaction.EdgeReceipt:
		m.ResetReceipt()
		return nil
	case transaction.EdgeEvents:
		m.ResetEvents()
		return nil
	}
	return fmt.Errorf("unknown Transaction edge %s", name)
}

// TransactionReceiptMutation represents an operation that mutates the TransactionReceipt nodes in the graph.
type TransactionReceiptMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	transaction_hash   *string
	status             *transactionreceipt.Status
	status_data        *string
	messages_sent      *[]*types.L1Message
	l1_origin_message  **types.L2Message
	clearedFields      map[string]struct{}
	block              *string
	clearedblock       bool
	transaction        *string
	clearedtransaction bool
	done               bool
	oldValue           func(context.Context) (*TransactionReceipt, error)
	predicates         []predicate.TransactionReceipt
}

var _ ent.Mutation = (*TransactionReceiptMutation)(nil)

// transactionreceiptOption allows management of the mutation configuration using functional options.
type transactionreceiptOption func(*TransactionReceiptMutation)

// newTransactionReceiptMutation creates new mutation for the TransactionReceipt entity.
func newTransactionReceiptMutation(c config, op Op, opts ...transactionreceiptOption) *TransactionReceiptMutation {
	m := &TransactionReceiptMutation{
		config:        c,
		op:            op,
		typ:           TypeTransactionReceipt,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTransactionReceiptID sets the ID field of the mutation.
func withTransactionReceiptID(id string) transactionreceiptOption {
	return func(m *TransactionReceiptMutation) {
		var (
			err   error
			once  sync.Once
			value *TransactionReceipt
		)
		m.oldValue = func(ctx context.Context) (*TransactionReceipt, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TransactionReceipt.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTransactionReceipt sets the old TransactionReceipt of the mutation.
func withTransactionReceipt(node *TransactionReceipt) transactionreceiptOption {
	return func(m *TransactionReceiptMutation) {
		m.oldValue = func(context.Context) (*TransactionReceipt, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TransactionReceiptMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TransactionReceiptMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TransactionReceipt entities.
func (m *TransactionReceiptMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TransactionReceiptMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TransactionReceiptMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TransactionReceipt.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTransactionHash sets the "transaction_hash" field.
func (m *TransactionReceiptMutation) SetTransactionHash(s string) {
	m.transaction_hash = &s
}

// TransactionHash returns the value of the "transaction_hash" field in the mutation.
func (m *TransactionReceiptMutation) TransactionHash() (r string, exists bool) {
	v := m.transaction_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldTransactionHash returns the old "transaction_hash" field's value of the TransactionReceipt entity.
// If the TransactionReceipt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionReceiptMutation) OldTransactionHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransactionHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransactionHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransactionHash: %w", err)
	}
	return oldValue.TransactionHash, nil
}

// ResetTransactionHash resets all changes to the "transaction_hash" field.
func (m *TransactionReceiptMutation) ResetTransactionHash() {
	m.transaction_hash = nil
}

// SetStatus sets the "status" field.
func (m *TransactionReceiptMutation) SetStatus(t transactionreceipt.Status) {
	m.status = &t
}

// Status returns the value of the "status" field in the mutation.
func (m *TransactionReceiptMutation) Status() (r transactionreceipt.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the TransactionReceipt entity.
// If the TransactionReceipt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionReceiptMutation) OldStatus(ctx context.Context) (v transactionreceipt.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TransactionReceiptMutation) ResetStatus() {
	m.status = nil
}

// SetStatusData sets the "status_data" field.
func (m *TransactionReceiptMutation) SetStatusData(s string) {
	m.status_data = &s
}

// StatusData returns the value of the "status_data" field in the mutation.
func (m *TransactionReceiptMutation) StatusData() (r string, exists bool) {
	v := m.status_data
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusData returns the old "status_data" field's value of the TransactionReceipt entity.
// If the TransactionReceipt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionReceiptMutation) OldStatusData(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatusData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatusData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusData: %w", err)
	}
	return oldValue.StatusData, nil
}

// ResetStatusData resets all changes to the "status_data" field.
func (m *TransactionReceiptMutation) ResetStatusData() {
	m.status_data = nil
}

// SetMessagesSent sets the "messages_sent" field.
func (m *TransactionReceiptMutation) SetMessagesSent(t []*types.L1Message) {
	m.messages_sent = &t
}

// MessagesSent returns the value of the "messages_sent" field in the mutation.
func (m *TransactionReceiptMutation) MessagesSent() (r []*types.L1Message, exists bool) {
	v := m.messages_sent
	if v == nil {
		return
	}
	return *v, true
}

// OldMessagesSent returns the old "messages_sent" field's value of the TransactionReceipt entity.
// If the TransactionReceipt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionReceiptMutation) OldMessagesSent(ctx context.Context) (v []*types.L1Message, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessagesSent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessagesSent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessagesSent: %w", err)
	}
	return oldValue.MessagesSent, nil
}

// ResetMessagesSent resets all changes to the "messages_sent" field.
func (m *TransactionReceiptMutation) ResetMessagesSent() {
	m.messages_sent = nil
}

// SetL1OriginMessage sets the "l1_origin_message" field.
func (m *TransactionReceiptMutation) SetL1OriginMessage(t *types.L2Message) {
	m.l1_origin_message = &t
}

// L1OriginMessage returns the value of the "l1_origin_message" field in the mutation.
func (m *TransactionReceiptMutation) L1OriginMessage() (r *types.L2Message, exists bool) {
	v := m.l1_origin_message
	if v == nil {
		return
	}
	return *v, true
}

// OldL1OriginMessage returns the old "l1_origin_message" field's value of the TransactionReceipt entity.
// If the TransactionReceipt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionReceiptMutation) OldL1OriginMessage(ctx context.Context) (v *types.L2Message, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldL1OriginMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldL1OriginMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldL1OriginMessage: %w", err)
	}
	return oldValue.L1OriginMessage, nil
}

// ResetL1OriginMessage resets all changes to the "l1_origin_message" field.
func (m *TransactionReceiptMutation) ResetL1OriginMessage() {
	m.l1_origin_message = nil
}

// SetBlockID sets the "block" edge to the Block entity by id.
func (m *TransactionReceiptMutation) SetBlockID(id string) {
	m.block = &id
}

// ClearBlock clears the "block" edge to the Block entity.
func (m *TransactionReceiptMutation) ClearBlock() {
	m.clearedblock = true
}

// BlockCleared reports if the "block" edge to the Block entity was cleared.
func (m *TransactionReceiptMutation) BlockCleared() bool {
	return m.clearedblock
}

// BlockID returns the "block" edge ID in the mutation.
func (m *TransactionReceiptMutation) BlockID() (id string, exists bool) {
	if m.block != nil {
		return *m.block, true
	}
	return
}

// BlockIDs returns the "block" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BlockID instead. It exists only for internal usage by the builders.
func (m *TransactionReceiptMutation) BlockIDs() (ids []string) {
	if id := m.block; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBlock resets all changes to the "block" edge.
func (m *TransactionReceiptMutation) ResetBlock() {
	m.block = nil
	m.clearedblock = false
}

// SetTransactionID sets the "transaction" edge to the Transaction entity by id.
func (m *TransactionReceiptMutation) SetTransactionID(id string) {
	m.transaction = &id
}

// ClearTransaction clears the "transaction" edge to the Transaction entity.
func (m *TransactionReceiptMutation) ClearTransaction() {
	m.clearedtransaction = true
}

// TransactionCleared reports if the "transaction" edge to the Transaction entity was cleared.
func (m *TransactionReceiptMutation) TransactionCleared() bool {
	return m.clearedtransaction
}

// TransactionID returns the "transaction" edge ID in the mutation.
func (m *TransactionReceiptMutation) TransactionID() (id string, exists bool) {
	if m.transaction != nil {
		return *m.transaction, true
	}
	return
}

// TransactionIDs returns the "transaction" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TransactionID instead. It exists only for internal usage by the builders.
func (m *TransactionReceiptMutation) TransactionIDs() (ids []string) {
	if id := m.transaction; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTransaction resets all changes to the "transaction" edge.
func (m *TransactionReceiptMutation) ResetTransaction() {
	m.transaction = nil
	m.clearedtransaction = false
}

// Where appends a list predicates to the TransactionReceiptMutation builder.
func (m *TransactionReceiptMutation) Where(ps ...predicate.TransactionReceipt) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TransactionReceiptMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TransactionReceipt).
func (m *TransactionReceiptMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TransactionReceiptMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.transaction_hash != nil {
		fields = append(fields, transactionreceipt.FieldTransactionHash)
	}
	if m.status != nil {
		fields = append(fields, transactionreceipt.FieldStatus)
	}
	if m.status_data != nil {
		fields = append(fields, transactionreceipt.FieldStatusData)
	}
	if m.messages_sent != nil {
		fields = append(fields, transactionreceipt.FieldMessagesSent)
	}
	if m.l1_origin_message != nil {
		fields = append(fields, transactionreceipt.FieldL1OriginMessage)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TransactionReceiptMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case transactionreceipt.FieldTransactionHash:
		return m.TransactionHash()
	case transactionreceipt.FieldStatus:
		return m.Status()
	case transactionreceipt.FieldStatusData:
		return m.StatusData()
	case transactionreceipt.FieldMessagesSent:
		return m.MessagesSent()
	case transactionreceipt.FieldL1OriginMessage:
		return m.L1OriginMessage()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TransactionReceiptMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case transactionreceipt.FieldTransactionHash:
		return m.OldTransactionHash(ctx)
	case transactionreceipt.FieldStatus:
		return m.OldStatus(ctx)
	case transactionreceipt.FieldStatusData:
		return m.OldStatusData(ctx)
	case transactionreceipt.FieldMessagesSent:
		return m.OldMessagesSent(ctx)
	case transactionreceipt.FieldL1OriginMessage:
		return m.OldL1OriginMessage(ctx)
	}
	return nil, fmt.Errorf("unknown TransactionReceipt field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionReceiptMutation) SetField(name string, value ent.Value) error {
	switch name {
	case transactionreceipt.FieldTransactionHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransactionHash(v)
		return nil
	case transactionreceipt.FieldStatus:
		v, ok := value.(transactionreceipt.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case transactionreceipt.FieldStatusData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusData(v)
		return nil
	case transactionreceipt.FieldMessagesSent:
		v, ok := value.([]*types.L1Message)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessagesSent(v)
		return nil
	case transactionreceipt.FieldL1OriginMessage:
		v, ok := value.(*types.L2Message)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetL1OriginMessage(v)
		return nil
	}
	return fmt.Errorf("unknown TransactionReceipt field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TransactionReceiptMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TransactionReceiptMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionReceiptMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TransactionReceipt numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TransactionReceiptMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TransactionReceiptMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TransactionReceiptMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TransactionReceipt nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TransactionReceiptMutation) ResetField(name string) error {
	switch name {
	case transactionreceipt.FieldTransactionHash:
		m.ResetTransactionHash()
		return nil
	case transactionreceipt.FieldStatus:
		m.ResetStatus()
		return nil
	case transactionreceipt.FieldStatusData:
		m.ResetStatusData()
		return nil
	case transactionreceipt.FieldMessagesSent:
		m.ResetMessagesSent()
		return nil
	case transactionreceipt.FieldL1OriginMessage:
		m.ResetL1OriginMessage()
		return nil
	}
	return fmt.Errorf("unknown TransactionReceipt field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TransactionReceiptMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.block != nil {
		edges = append(edges, transactionreceipt.EdgeBlock)
	}
	if m.transaction != nil {
		edges = append(edges, transactionreceipt.EdgeTransaction)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TransactionReceiptMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case transactionreceipt.EdgeBlock:
		if id := m.block; id != nil {
			return []ent.Value{*id}
		}
	case transactionreceipt.EdgeTransaction:
		if id := m.transaction; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TransactionReceiptMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TransactionReceiptMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TransactionReceiptMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedblock {
		edges = append(edges, transactionreceipt.EdgeBlock)
	}
	if m.clearedtransaction {
		edges = append(edges, transactionreceipt.EdgeTransaction)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TransactionReceiptMutation) EdgeCleared(name string) bool {
	switch name {
	case transactionreceipt.EdgeBlock:
		return m.clearedblock
	case transactionreceipt.EdgeTransaction:
		return m.clearedtransaction
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TransactionReceiptMutation) ClearEdge(name string) error {
	switch name {
	case transactionreceipt.EdgeBlock:
		m.ClearBlock()
		return nil
	case transactionreceipt.EdgeTransaction:
		m.ClearTransaction()
		return nil
	}
	return fmt.Errorf("unknown TransactionReceipt unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TransactionReceiptMutation) ResetEdge(name string) error {
	switch name {
	case transactionreceipt.EdgeBlock:
		m.ResetBlock()
		return nil
	case transactionreceipt.EdgeTransaction:
		m.ResetTransaction()
		return nil
	}
	return fmt.Errorf("unknown TransactionReceipt edge %s", name)
}
